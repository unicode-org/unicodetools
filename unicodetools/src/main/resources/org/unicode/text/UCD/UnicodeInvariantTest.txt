# Invariance Tests
#
# This file provides a set of machine-readable invariance tests for Unicode Properties.
#
##########################
# Format
##########################
# Let <$variable> = <unicodeSet>
#  Assign a variable to a value. The variable must start with $.
#
# <unicodeSet> is a boolean combinations of properties and character ranges, as defined in LDML, 
#  with the following extensions.
#
#  Example:
#   [\p{General_Category=Unassigned}-[a-zA-Z]]
#
# Property Name:
#   <propertyName> can be the short or long form as in the PropertyAliases.txt
#   <propertyName> can be prefixed with "U<version>:"
#   Example: \p{U5.1.0:Whitespace}
#
#   A version of -1 indicates the previous released major version.
#   For example, if the version is 4.1, then the U-1 version is 4.0.
#   The property values are as supplied in the release, without any subsequent corrigenda being applied. 
#   Example: \p{U-1:Whitespace}
#
# Property Value:
#   If the propertyValue is missing, it is defaulted to true
#   If the value is of the form /.../, then the ... is interpreted as a regular expression
#   The value (if enumerated) can be the short or long form as in PropertyValueAliases.txt
##########################
# Show <unicodeSet>
#  List any set on the console, for viewing and debugging.
##########################
# Test <unicodeSet> <relation> <unicodeSet>
#
# Tests that the relation is true for the two sets. The "Test" keyword is optional.
#
#   relation := '='             // has identical contents to
#            := '⊃'             // is proper superset of
#            := '⊇'             // is superset of 
#            := '⊂'             // is proper subset of
#            := '⊆'             // is subset of
#            := '∥'             // has no intersection
#            := '≉'             // none of the above (they overlap, and neither contains the other)
#
# When this file is parsed, a parse error message may contain <@>
# to indicate the location of an error in the input line.
#
# If there is an error in the test, a comparison listing of the two sides of the relation is generated.
##########################
# In <unicodeSet>, <props> (=|≠) <props>
#
# For each character in <unicodeSet>, verify that the result of applying the left <props>
# is (=|≠) the result of applying the right <props>.
#   <props> is of the form (<unicodeSet> | <prop>) ("*" (<unicodeSet> | <prop> | <sequenceTransformation>))?
#   It is the functional composition of the properties applied to strings, whereby
#   <unicodeSet> is used to filter the result.
#   <prop> for a string property is applied to each character, and the result concatenated
#       That is, cf("A1") is cf("A")+cf("1") = "a1"
#   <prop> for an enumerated property is applied to each character, and the result is a sequence of
#   strings.
#       That is, gc("A1") is [gc("A"), gc("1")] = ["Uppercase_Letter", "Decimal_Number"]
#   <sequenceTransformation> may be applied to a sequence of strings or to a string.  On a string it
#   operates on the code points and returns a string.
#       The available operations are:
#           (append <string>)
#           (prepend <string>)
#           (take <n>)
#           (drop <n>)
#           (delete-adjacent-duplicates)
#           (string-join)
#           (constant <string>)
#   The result of the <props> must be a string, a single-string sequence, or an empty sequence.
#
#   Example: for <props> of bc * \P{bc=NSM} * cf * dm, the result applied to Å (angstrom sign) are:
#       bc * \P{bc=NSM} * cf * dm ("Å")
#       bc * \P{bc=NSM} * cf ("A" + umlaut)
#       bc * \P{bc=NSM} ("a" + umlaut)
#       bc ("a")
#       "Left_To_Right"
#
#   Example: In \p{dt=canonical}, (delete-adjacent-duplicates) * bc * \P{bc=NSM} * dm = bc * \P{bc=NSM}
#       This examines only those characters that have canonical compositions. For each such character X
#       it gets the decomposition mapping of X, then filters out all NSM characters, then gets the Bidi_Class,
#       then deduplicates runs of the same Bidi_Class.
#       It then compares that with the result of filtering out NSM characters from X, then getting the Bidi_Class.
#
# In <unicodeSet>, <props> (∈|∉) <unicodeSet>
#   For each character in the first <unicodeSet>, verify that the result of applying the left <props>
#   is (∈|∉) the right-hand-side unicodeSet.
##########################
# OnPairsOf <unicodeSet>, EqualityOf <props> (⇐|⇔|⇒|⇍|⇎|⇏) EqualityOf <props>
# 
# Verify that the equivalence of elements of <unicodeSet> up to the left <props> is is implied,
# equivalent, or implies equivalence up to the right <props>, or verify the negation of these
# relations.
#
# On both sides, <props> is a composition of properties and filters, as in an “In” line.
#
#   Example:
#       The case-insensitive comparison of ASCII identifiers defined by comparing their uppercase
#       mappings is equivalent to that defined by comparing their lowercase mappings:
#          OnPairsOf \p{Block=Basic Latin}, EqualityOf Uppercase_Mapping ⇔ EqualityOf Lowercase_Mapping
#       This is not true in the broader Latin script (in fact neither implication holds).
#          OnPairsOf \p{Script=Latin}, EqualityOf Uppercase_Mapping ⇎ EqualityOf Lowercase_Mapping
#       The simple and full case foldings do not define the same equivalence classes on these
#       strings:
#          Let $strings = [ {Straße} {STRASSE} {ᾠδή} {ὨΙΔΉ} {...} ]
#          OnPairsOf $strings, EqualityOf Case_Folding ⇎ EqualityOf Simple_Case_Folding
#       Specifically, full case folding is coarser than simple case folding.
#          OnPairsOf $strings, EqualityOf Case_Folding ⇏ EqualityOf Simple_Case_Folding
#          OnPairsOf $strings, EqualityOf Case_Folding ⇐ EqualityOf Simple_Case_Folding
##########################
# Ignoring <properties>:
#     <propertywise checks>
# end Ignoring;
#
# Within an ignoring block, the properties listed in the space-separated list <properties>
# are ignored in Propertywise checks.
# Only Propertywise checks can occur within Ignoring blocks.
# Propertywise checks can only occur within Ignoring blocks.
#
##########################
# Propertywise <unicodeSet> AreAlike
#
# Checks that all property assignments of the code points in <unicodeSet> are the same,
# except for any ignored properties.
#
# For the purposes of this check, if all characters in <unicodeSet> are mapped to themselves
# by some property with default value <code point>, these assignments are the same.
#
#   Examples:
#       The Linear A signs A751 and A752 behave identically (of course they have different
#       names).
            Ignoring Name:
                Propertywise [𐛪 𐛫] AreAlike
#       Yeh (with two dots) and yeh with three dots behave the same, except for confusability and
#       their name in Unicode 1 (both had one that differs from their current name).
                Ignoring Unicode_1_Name Confusable_MA:
                    Propertywise [ي ۑ] AreAlike
                end Ignoring;
            end Ignoring;
#
##########################
# Propertywise <S₁> : ... <Sₘ> [ ⧴ <Sₘ₊₁> ⧴ ... ⧴ <Sₙ> ]
# CorrespondTo <R₁> : ... <Rₘ> [ ⧴ <Rₘ₊₁> ⧴ ... ⧴ <Rₙ> ]
# [   UpTo: <Property> (<SValue> vs <RValue>) {, <Property> (<SValue> vs <RValue>) }]
#
# The Sₖ must be Unicode sets of equal size, either with no strings or only strings.
# They are considered in code point order for the correspondence check (item 2 below).
# The references Rₖ must be Unicode sets each containing a single code point or a single string;
# by a slight abuse of notation we refer to the code point or string as Rₖ in the explanation below.
# For k ≤ m, Rₖ must be a code point and Sₖ must contain only code points.
# For every non-ignored property P that does not appear in the optional UpTo clause,
# checks that for each k in 1 .. m, for the ith character C in Sₖ, either:
# 1. P(C) = P(Rₖ), or
# 2. for some l in 1 .. n, both:
#    — P(Rₖ) is equal to Rₗ, and
#    — P(C) is equal to the ith character (or string, if l > m) in Sₗ.
# For every non-ignored property P that appears in the UpTo clause, checks all characters in the
# sets Sₖ have the SValue and all R characters have the RValue.
#
# Note that only the properties of the characters in Sₖ and Rₖ where k ≤ m are inspected; in other
# words, the characters and strings prefixed by ⧴ are only considered as property values.
#
# With n=1 this check is equivalent to the more straightforward AreAlike check; however, it also
# allows for testing of properties such as case mappings, which differ for most characters in a
# script, but behave regularly.  See the examples below.
#
#   Examples:
            Ignoring Name Unicode_1_Name Confusable_MA:
#       The basic Greek and Latin scripts behave the same, except that they are different scripts,
#       encoded in different blocks, and that Latin is ea=Narrow (because fullwidth Latin exists)
#       whereas Greek is ea=Ambiguous.
#       In particular, this checks that the lowercase and uppercase greek letters map to each other
#       under the case properties in the same way that Latin g and G do.
                Propertywise [[α-ω] - [ς]] : [[Α-Ω] - \p{gc=Cn}]
                CorrespondTo [g]           :  [G]
                    UpTo: Block             (Greek_And_Coptic vs Basic_Latin),
                          Script            (Greek            vs Latin),
                          Script_Extensions (Greek            vs Latin),
                          East_Asian_Width  (Ambiguous        vs Narrow)
#       The modifier letters ʳʷʸ are related to their non-superscripted counterparts in the same way
#       that ʰ is related to h.  The capitals must be part of the correspondence because they are
#       property values of the lowercase letters.
                Propertywise [ʳʷʸ] : [rwy] : [RWY]
                CorrespondTo [ʰ]   : [h]   : [H]
            end Ignoring;
#
##########################
# There is new syntax for testing UnicodeMaps
#
#  Map <unicodeMap> <relation> <unicodeMap>
#
#    unicodeMap   := { um_list }
#    umList       := umItem (addItem | removeItem | retainItem)*
#
#    umItem       := unicodeSet '=' value
#    umItem       := '\m{' '*'? propertyName '}' // the * indicates the last version, equiv to U-1: for properties.
#
#    addList      := [,|] umItem
#    removeItem   := '-' (umItem | unicodeSet) // you can remove keys (unicodeSet) from a map
#    retainItem   := '&' (umItem | unicodeSet) // you can retain keys (unicodeSet) in a map (removing others)
#
# A map is logically a set of pairs {<key1,value1​>, <key2,value2>...}, where the keys are unique
#    You can add another map to it. If any new pair has the same key as an old one, the old pair is removed.
#    You can remove a map or set from it. (Set-Difference)
#        For a set, this removes all the keys that are in the set.
#        For a map, this removes those pairs that are identical.
#    You can also retain elements from a map or set. (Intersection)
#        Sets vs Maps work similarly to removal.
#
# The relation tests the set of pairs. So two maps are equal when the pairs are the same.
#
# TODO:
#    Add value operations:
#    - remove/retain pairs with particular values
#    - extract the set of keys from a map, for pairs with particular values
#
# For debugging, you can also use:
#  ShowMap <unicodeMap>
# For example: 
#  ShowMap {\m{whitespace}-\p{whitespace=no},{[b]=strangeValue}}
#  this gets the map for whitespace, eg {' '=Yes, 'a'=No, ...}, subtracts the entries with No, and adds 'b'=strangeValue
##########################
# General Constants
##########################

Let $foo := \p{ccc=9}
Let $fii := \p{toNFD=/$foo/}

Let $codepoints := [\u0000-\U0010FFFF]

Let $gcAllPunctuation := \p{gc=/_Punctuation/}
$gcAllPunctuation = [
    \p{gc=Close_Punctuation}
    \p{gc=Connector_Punctuation}
    \p{gc=Dash_Punctuation}
    \p{gc=Final_Punctuation}
    \p{gc=Initial_Punctuation}
    \p{gc=Open_Punctuation}
    \p{gc=Other_Punctuation}
]

Let $gcAllSymbols := \p{gc=/_Symbol/}
$gcAllSymbols = [\p{gc=Math_Symbol}\p{gc=Currency_Symbol}\p{gc=Modifier_Symbol}\p{gc=Other_Symbol}]

Let $gcAllMarks := \p{gc=/_Mark/}
$gcAllMarks = [\p{gc=Nonspacing_Mark}\p{gc=Enclosing_Mark}\p{gc=Spacing_Mark}]

Let $gcAllLetters := \p{gc=/_Letter/}
$gcAllLetters = [\p{gc=Ll}\p{gc=Lu}\p{gc=Lo}\p{gc=Lt}\p{gc=Lm}]

##########################
# Main Stability Policies 
#   http://www.unicode.org/policies/property_value_stability_table.html
##########################

# TODO: Formal Name Alias Stability, Named Character Sequence Stability, Name Uniqueness, 
# TODO: Identity Stability, Property Stability, Alias Stability, Property Alias Uniqueness

# Encoding Stability: Once a character is encoded, it will not be moved or removed.
\p{GC=unassigned} ⊆ \p{U-1:GC=unassigned}

# Name Stability: The Unicode Name property value for any non-reserved code point will not be changed. In particular, once a character is encoded, its name will not be changed.
In \P{U-1:GC=Cn}, name=U-1:name

# Formal Name Alias Stability
# TODO

# Named Character Sequence Stability
# TODO

# Name Uniqueness
# TODO

# Strong Normalization Stability (decomposition mapping, Canonical Combining Class don't change)
# In Property Section

# Identity Stability
# Can't be tested

# Property Stability: Normative and informative properties, once defined in the Unicode Character Database, will never be removed.
# TODO
    
# Alias Stability: Property aliases and property value aliases, once defined in the Unicode Character Database, will never be removed.
# TODO

# Property Alias Uniqueness: All property aliases constitute a single namespace. Property aliases are guaranteed to be unique within this namespace. For each property, all of its property value aliases constitute a separate namespace, one per property. Within each of these property value alias namespaces, property value aliases are guaranteed to be unique.
# TODO

# Identifier Stability: All strings that are valid default Unicode identifiers will continue to be valid default Unicode identifiers in all subsequent versions of Unicode. Furthermore, default identifiers never contain characters with the Pattern_Syntax or Pattern_White_Space properties.
# Covered in Property Stability Section

# Case Folding Stability: Caseless matching of Unicode strings used for identifiers is stable.
# For each string S containing only assigned characters in a given Unicode version, toCasefold(toNFKC(S)) under that version is identical to toCasefold(toNFKC(S)) under any later version of Unicode.
In \P{U-1:gc=Cn}, U-1:Case_Folding * U-1:toNFKC = Case_Folding * toNFKC
# For each string S containing only characters with the property XID_Continue in a given Unicode version, toNFKC_Casefold(S) under that version is identical to toNFKC_Casefold(S) under any later version of Unicode.
# If this is violated as a result of a change to Default_Ignorable_Code_Point, the derivation of NFKC_Casefold must special-case the affected characters to restore stability.
In \p{U-1:XID_Continue}, U-1:NFKC_Casefold = NFKC_Casefold
# The following is not guaranteed by the stability policy, indeed it does not hold as far back as 5.2, but we might want to know about it:
In \P{U-1:gc=Cn}, U-1:NFKC_Casefold = NFKC_Casefold

# Not yet a stability policy, but see https://www.unicode.org/L2/L2023/23005.htm#174-A11.
# Simple counterparts of the above.
In \P{U-1:gc=Cn}, U-1:Simple_Case_Folding * U-1:toNFKC = Simple_Case_Folding * toNFKC
In \p{U-1:XID_Continue}, R-1:NFKC_Simple_Casefold = NFKC_Simple_Casefold
# As above, this one would not be guaranteed by the stability policy.
In \P{U-1:gc=Cn}, R-1:NFKC_Simple_Casefold = NFKC_Simple_Casefold

# Case Pair Stability: If two characters form a case pair in a version of Unicode, they will remain a case pair in each subsequent version of Unicode. If two characters do not form a case pair in a version of Unicode, they will never become a case pair in any subsequent version of Unicode.
# TODO

# Red Flag: cased and case_ignorable should be disjoint,
# except for modifier letters and ◌ͅ.

\p{Cased} ∥ [\p{Case_Ignorable} - \p{gc=Lm} - [\N{COMBINING GREEK YPOGEGRAMMENI}] ]

##########################
# Property Stability Policies
#   http://www.unicode.org/policies/stability_policy.html#Property_Value
##########################

##########################
# BIDI
##########################

# Stability: The Bidi_Class property values will not be further subdivided. 
\p{bc=/^(AL|AN|B|BN|CS|EN|ES|ET|L|LRE|LRO|NSM|ON|PDF|R|RLE|RLO|S|WS|LRI|RLI|FSI|PDI)$/} = [\u0000-\U0010FFFF]

# Stability: The property values for the bidirectional properties Bidi_Class and Bidi_Mirrored preserve canonical equivalence.
# This test utilizes the fact that bc=NSM inherit behavior in the algorithm, so these are just filtered
In \p{dt=canonical}, (delete-adjacent-duplicates) * bc * \P{bc=NSM} * dm = bc * \P{bc=NSM}

# Stability: The property values for the bidirectional properties Bidi_Class and Bidi_Mirrored preserve canonical equivalence.
# This test utilizes the fact that bc=NSM inherit behavior in the algorithm, so these are just filtered
# There are 6 special cases, all symmetric symbols—which are not mirrored—with a solidus overlay:
Let $BMExclusions := [ ≠ ∤ ∦ ≢ ≭ ⫝̸ ]
In [\p{dt=canonical}-$BMExclusions], (delete-adjacent-duplicates) * Bidi_M * \P{bc=NSM} * dm = Bidi_M * \P{bc=NSM}

# Additional BIDI invariant constants
Let $AL_blocks := [
    \u0600-\u07BF
    \u0860-\u086F          # Syriac Supplement,     10.0
    \u0870-\u089F          # Arabic Extended-B,     14.0
    \u08A0-\u08FF
    \uFB50-\uFDCF
    \uFDF0-\uFDFF
    \uFE70-\uFEFF
    \U00010D00-\U00010D3F  # Hanifi Rohingya,       11.0
    \U00010EC0-\U00010EFF
    \U00010F30-\U00010F6F  # Sogdian,               11.0
    \U0001EC70-\U0001ECBF  # Indic Siyaq Numbers,   11.0
    \U0001ED00-\U0001ED4F  # Ottoman Siyaq Numbers, 12.0
    \U0001EE00-\U0001EEFF
]
Let $R_blocks := [
    \u0590-\u05FF
    \u07C0-\u085F
    \uFB1D-\uFB4F
    \U00010800-\U00010CFF
    \U00010D40-\U00010EBF
    \U00010F00-\U00010F2F
    \U00010F70-\U00010FFF
    \U0001E800-\U0001EC6F
    \U0001ECC0-\U0001ECFF
    \U0001ED50-\U0001EDFF
    \U0001EF00-\U0001EFFF
]

# Unassigned characters in these blocks have R or AL respectively
\p{Bidi_Class=R} ⊇ [$R_blocks & \p{gc=Cn}]
\p{Bidi_Class=AL} ⊇ [$AL_blocks & \p{gc=Cn}]

# There are no strong characters of the other directionalities (out of L, AL, R) in these blocks, 
# and anything R or L is in the block (or RLM)
$R_blocks ∥ [\p{Bidi_Class=L} \p{Bidi_Class=AL}]
$AL_blocks ∥ [\p{Bidi_Class=L} \p{Bidi_Class=R}]
[$R_blocks $AL_blocks \N{RIGHT-TO-LEFT MARK}] ⊇ [\p{Bidi_Class=AL} \p{Bidi_Class=R}] #200f


# U6.0: BN characters are default ignorable, noncharacters, controls, minus marks, bidi-controls, alphabetic, whitespace, with a few exceptions

Let $BN_Exceptions := [\u001C-\u001F\u17B4\u17B5]

[\p{Bidi_Class=BN}] = [
    \p{di}\p{nchar}\p{gc=Cc}
    - \p{gc=Mc} - \p{gc=Mn} - \p{gc=Me}
    - \p{Bidi_C}
    - \p{alpha}
    - \p{wspace}
    - $BN_Exceptions
]

# Nonspacing and enclosing combining marks are bc=NSM, with a few exceptions (all of which are nonspacing)
Let $gcMn_bcL := [\u0CBF\u0CC6\U00011A07\U00011A08\U00011C3F]
\p{bc=NSM} = [\p{gc=Mn} \p{gc=Me} - $gcMn_bcL]

##########################
# Case
##########################

# Stability: The Case_Folding property value is limited so that no string when case folded expands to more than 3× in length (measured in code units). 
\p{cf=/..../} = []
# Note: This bound is tight:
\p{cf=/.../} ⊃ []

# Case folding is not the same as lowercasing: Cherokee case folds to uppercase.
In \p{sc=Cher}, cf = uc
In \p{sc=Cher}, scf = suc

# Simple and full case foldings define the same equivalence classes on code points.
# This used not to be true, but was rectified by
# https://www.unicode.org/cgi-bin/GetL2Ref.pl?175-C19.
OnPairsOf $codepoints, EqualityOf Case_Folding ⇔ EqualityOf Simple_Case_Folding

# Stability: All characters with the Lowercase property and all characters with the Uppercase property have the Alphabetic property. 
\p{Alphabetic} ⊃ [\p{Uppercase} \p{Lowercase}]

##########################
# General
##########################

# Stability: The General_Category property values will not be further subdivided. 
\p{gc=/^(Cc|Cf|Cn|Co|Cs|Ll|Lm|Lo|Lt|Lu|Mc|Me|Mn|Nd|Nl|No|Pc|Pd|Pe|Pf|Pi|Po|Ps|Sc|Sk|Sm|So|Zl|Zp|Zs)$/} = [\u0000-\U0010FFFF]

# Stability: The General_Category property value Control (Cc) is immutable: the set of code points with that value will never change. 
\p{GC=Cc} = \p{U-1:GC=Cc}

# Stability: The General_Category property value Private_Use (Co) is immutable: the set of code points with that value will never change. 
\p{GC=Co} = \p{U-1:GC=Co}

# Stability: The General_Category property value Surrogate (Cs) is immutable: the set of code points with that value will never change.  
\p{GC=Cs} = \p{U-1:GC=Cs}

# Stability: The set of characters having General_Category=Nd will always be the same as the set of characters having Numeric_Type=de.
\p{General_Category=Decimal_Number} = \p{Numeric_Type=Decimal}

# Stability: Once a character is assigned, both its Name and its Jamo_Short_Name will never change. 
# Name is covered in Main policies
In \P{U-1:GC=Cn}, Jamo_Short_Name=U-1:Jamo_Short_Name

# Stability: The Noncharacter_Code_Point property is an immutable code point property, which means that its property values for all Unicode code points will never change.
\p{NChar} = \p{U-1:NChar}

##########################
# Identifier Stability
##########################

# Stability: Once a character is ID_Continue, it must continue to be so in all future versions. 
\p{ID_Continue} ⊇ \p{U-1:ID_Continue}

# Stability: If a character is ID_Start then it must also be ID_Continue. 
\p{ID_Continue} ⊇ \p{ID_Start}

# Stability: Once a character is ID_Start, it must continue to be so in all future versions. 
\p{ID_Start} ⊇ \p{U-1:ID_Start}

# Stability: Once a character is XID_Continue, it must continue to be so in all future versions. 
\p{XID_Continue} ⊇ \p{U-1:XID_Continue}

# Stability: If a character is XID_Start then it must also be XID_Continue. 
\p{XID_Continue} ⊇ \p{XID_Start}

# Stability: If a character is XID_Start then it must also be XID_Continue. 
\p{XID_Start} ⊇ \p{U-1:XID_Start}

# While the above stability policy is only applicable back to 4.1.0+ for the
# Continue properties, recent versions of Unicode are compatible further back.
# See https://www.unicode.org/cgi-bin/GetL2Ref.pl?176-C18.
\p{XID_Start} ⊇ \p{U3.1.0:XID_Start}
\p{ID_Start} ⊇ \p{U3.1.0:ID_Start}
\p{XID_Continue} ⊇ \p{U3.1.0:XID_Continue}
\p{ID_Continue} ⊇ \p{U3.1.0:ID_Continue}

# Stability: The Pattern_Syntax and Pattern_Whitespace properties are immutable code point properties, which means that their property values for all Unicode code points will never change.
\p{Pattern_Whitespace} = \p{U-1:Pattern_Whitespace}
\p{Pattern_Syntax} = \p{U-1:Pattern_Syntax}

# Stability: If a character has the Pattern_Syntax or Pattern_White_Space property, then it cannot have the ID_Continue or XID_Continue property.
# (Also tests that Pattern_Syntax is disjoint from Pattern_White_Space)

\p{ID_Continue} ∥ [\p{Pattern_Whitespace} \p{Pattern_Syntax}]
\p{Pattern_Whitespace} ∥ [\p{ID_Continue} \p{Pattern_Syntax}]
\p{Pattern_Syntax} ∥ [\p{ID_Continue} \p{Pattern_Whitespace}]

\p{XID_Continue} ∥ [\p{Pattern_Whitespace} \p{Pattern_Syntax}]
\p{Pattern_Whitespace} ∥ [\p{XID_Continue} \p{Pattern_Syntax}]
\p{Pattern_Syntax} ∥ [\p{XID_Continue} \p{Pattern_Whitespace}]

# The X versions are subsets of the the plain versions
# Should add as stability provision
\p{ID_Continue} ⊇ \p{XID_Continue}
\p{ID_Start} ⊇ \p{XID_Start}

# Not a stability policy, but we probably should avoid breaking it further:
# The sets \p{ID_Start} and and \p{ID_Continue} preserve backward compatibility
# with the General_Category-based identifier definition from Unicode 3.0, except
# for \p{Cf}, which was ignored in identifier comparison, and for one—thankfully
# obscure—letter added to \p{Pattern_Syntax} in Unicode 5.1.
# See https://www.unicode.org/versions/Unicode3.0.0/ch05.pdf#page=31.
#
# NOTE: If this invariant needs to change, the section on migrating from the
#       Unicode 3.0 identifier definition in UTS #55 must be updated:
#       https://www.unicode.org/reports/tr55/#Evolution-Unicode-3.
Let $identifier_start := [\p{GC=Lu}\p{GC=Ll}\p{GC=Lt}\p{GC=Lm}\p{GC=Lo}\p{GC=Nl}]
Let $identifier_extend := [\p{GC=Mn}\p{GC=Mc}\p{GC=Nd}\p{GC=Pc}]
[\p{ID_Start}\p{Name=VERTICAL TILDE}]    ⊇ $identifier_start
[\p{ID_Continue}\p{Name=VERTICAL TILDE}] ⊇ [$identifier_start $identifier_extend]

[\p{XID_Start}\p{Name=VERTICAL TILDE}]    ⊇ [$identifier_start-\p{NFKC_QC=No}]
[\p{XID_Continue}\p{Name=VERTICAL TILDE}] ⊇ [[$identifier_start $identifier_extend]-\p{NFKC_QC=No}]

##########################
# Normalization
##########################

# Stability: The Canonical_Combining_Class property values are limited to the values 0 to 255. 
\p{CCC=/^([0-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/} = [\u0000-\U0010FFFF]

# Stability: Once a character is assigned, its Canonical_Combining_Class will never change. 
In \P{U-1:GC=Cn}, ccc=U-1:ccc

# Canonical decompositions (minus exclusions) must be identical across releases (also required by strong normalization stability),
# except where a character and at least one character in its decomposition are both new in the release.
Let $New_Decompositions := [
      [    \p{Decomposition_Type=Canonical} -     \p{Full_Composition_Exclusion}]
    - [\p{U-1:Decomposition_Type=Canonical} - \p{U-1:Full_Composition_Exclusion}]
]
$New_Decompositions ⊆ \p{U-1:GC=Cn}
# Stripping previously-unassigned characters from the current NFD does
# something, that is, the decomposition contains newly-assigned characters.
In $New_Decompositions, toNFD * \P{U-1:GC=Cn} ≠ toNFD

Let $Unicode_13_Decompositions := [
      [\p{U13.0.0:Decomposition_Type=Canonical} - \p{U13.0.0:Full_Composition_Exclusion}]
    - [\p{U12.1.0:Decomposition_Type=Canonical} - \p{U12.1.0:Full_Composition_Exclusion}]
]
$Unicode_13_Decompositions ⊆ \p{U12.1.0:GC=Cn}
In $Unicode_13_Decompositions, toNFD * \P{U12.1.0:GC=Cn} ≠ toNFD
$Unicode_13_Decompositions = [\U00011938]
$Unicode_13_Decompositions = [\p{Name=DIVES AKURU VOWEL SIGN O}]

Let $Unicode_7_Decompositions := [
      [\p{U7.0.0:Decomposition_Type=Canonical} - \p{U7.0.0:Full_Composition_Exclusion}]
    - [\p{U6.3.0:Decomposition_Type=Canonical} - \p{U6.3.0:Full_Composition_Exclusion}]
]
$Unicode_7_Decompositions ⊆ \p{U6.3.0:GC=Cn}
In $Unicode_7_Decompositions, toNFD * \P{U6.3.0:GC=Cn} ≠ toNFD
$Unicode_7_Decompositions = [\U0001134B-\U0001134C \U000114BB-\U000114BC \U000114BE \U000115BA-\U000115BB]
$Unicode_7_Decompositions ⊆ [\p{Name=/^(GRANTHA|TIRHUTA|SIDDHAM) VOWEL SIGN /}]

Let $Unicode_6_1_Decompositions := [
      [\p{U6.1.0:Decomposition_Type=Canonical} - \p{U6.1.0:Full_Composition_Exclusion}]
    - [\p{U6.0.0:Decomposition_Type=Canonical} - \p{U6.0.0:Full_Composition_Exclusion}]
]
$Unicode_6_1_Decompositions ⊆ \p{U6.0.0:GC=Cn}
In $Unicode_6_1_Decompositions, toNFD * \P{U6.0.0:GC=Cn} ≠ toNFD
$Unicode_6_1_Decompositions = [\U0001112E-\U0001112F]
$Unicode_6_1_Decompositions ⊆ [\p{Name=/^CHAKMA VOWEL SIGN /}]

# Stability: All characters other than those with General_Category property values Spacing_Mark (Mc) and Nonspacing_Mark (Mn) have the Canonical_Combining_Class property value 0.
\p{CCC=0} ⊇ [^ \p{GC=Mc} \p{GC=Mn}]

# Stability: Canonical and compatibility mappings (Decomposition_Mapping
# property values) are always in canonical order, and the resulting recursive
# decomposition will also be in canonical order. 
# Note: We really mean the fixed point of Decomposition_Mapping on the
# left-hand side here.
In $codepoints, Decomposition_Mapping * Decomposition_Mapping * Decomposition_Mapping = toNFKD

# Stability: Canonical mappings (Decomposition_Mapping property values) are
# always limited either to a single value or to a pair. The second character in
# the pair cannot itself have a canonical mapping.
[ \p{Decomposition_Type=Canonical} & \p{Decomposition_Mapping=/.../} ] = []
[ \p{Decomposition_Type=Canonical} & \p{Decomposition_Mapping=} ] = []
Let $expandingCanonicalDecompositions := [ \p{Decomposition_Type=Canonical} & \p{Decomposition_Mapping=/../} ]
In $expandingCanonicalDecompositions, Decomposition_Type * (drop 1) * Decomposition_Mapping ≠ (constant Canonical)
# Not a stability policy, but it happens to be the case that the second
# character does not have a decomposition mapping at all:
In $expandingCanonicalDecompositions, Decomposition_Type * (drop 1) * Decomposition_Mapping = (constant None)
In $expandingCanonicalDecompositions,
      Decomposition_Mapping * (drop 1) * Decomposition_Mapping
    =                         (drop 1) * Decomposition_Mapping

# Stability: Canonical mappings (Decomposition_Mapping property values) are
# always limited so that no string when normalized to NFC expands to more than
# 3× in length (measured in code units). 
\p{toNFC=/..../} = []
# Note: This bound is tight:
\p{toNFC=/.../} ⊃ []
# TODO(egg): Test that for UTF-16 and UTF-8 code units too.

# Stability: Once a character is assigned, its Decomposition_Mapping will never
# change. 
In \P{U-1:GC=Cn}, dm=U-1:dm

# Stability: Canonical mappings (Decomposition_Mapping property values) to a
# pair of characters are limited such that the first of the pair in the mapping
# must have ccc=0, except for the Decomposition_Mapping of the following four
# characters: U+0344, U+0F73, U+0F75, U+0F81.
Let $canonicallyExpandingNonstarters := [\u0344 \u0F73 \u0F75 \u0F81]
In [$expandingCanonicalDecompositions - $canonicallyExpandingNonstarters],
    ccc * (take 1) * Decomposition_Mapping = (constant Not_Reordered)

# U6.0: Construction of Full_Composition_Exclusion
# Primary Composites don't include singletons, ccc!=0, or sequences starting with ccc!=0
Let $combiningExclusions := [\p{dt=canonical}-\P{nfcqc=N}-\P{nfdqc=N}]

Let $singletons := \p{toNFD=/^.$/}
Let $nonstarter := \P{ccc=0}
Let $firstNonStarter := \p{toNFD=/^$nonstarter/}

$combiningExclusions ⊇ [$singletons & \p{dt=canonical}]
$combiningExclusions ⊇ [$nonstarter & \p{dt=canonical}]
$combiningExclusions ⊇ [$firstNonStarter & \p{dt=canonical}]

##########################
# Other Invariant Tests, not in Stability Policies
##########################

# 138-A029 check that STerm is a proper subset of Terminal_Punctuation

\p{Terminal_Punctuation} ⊃ \p{STerm}

# We forgot about Sentence_Terminal while working on 16.0α; this would have caught us.
\p{Name=/DANDA/} ⊆ \p{Sentence_Terminal}

# Sentence terminal punctuation is exactly
# ambiguous sentence terminal punctuation and unambiguous sentence terminal punctuation.
\p{Sentence_Terminal} = [\p{sb=ATerm}\p{sb=STerm}]

# 132-M3 if a character has a general category of "Number", it must have a numeric type that is not equal to "none".

[\p{General_Category=Decimal_Number}\p{General_Category=Letter_Number}\p{General_Category=Other_Number}] ∥ \p{Numeric_Type=None}

# [133-C25] The distinction between numeric type = digit and and numeric type = numeric is not useful. 
# No new characters will be assigned the numeric type "digit"

\p{Numeric_Type=Digit} = \p{U-1:Numeric_Type=Digit}

##########################
# Numbers
##########################

# Decimals are 0-9

Let $decimalValue := [\p{Numeric_Value=/^[0-9]+(.0)?$/}]

$decimalValue ⊇ \p{General_Category=Decimal_Number}

# All and only those items with numeric types have numeric values

Let $anyNumericValue := \p{Numeric_Value=/-?[0-9]+(.[0-9]+)?/}
[\p{Numeric_Type=Decimal} \p{Numeric_Type=Digit} \p{Numeric_Type=Numeric}] = $anyNumericValue

##########################
# Misc Properties
##########################

# Musical symbol combining marks, other oddities

Let $AlphaExclusions := [
    # TODO(egg): Make this list legible.
    [\uAA7D \u0F3E\u0F3F\u1063\u1064\u1069-\u106D\u1087-\u108C\u108F\u109A\u109B\u1CE1\u1CF7\uAA7B\uABEC\U0001D165\U0001D166\U0001D16D-\U0001D172]
    [[:gc=mc:]&[:ccc=9:][\u302E\u302F]]
    \p{Name=/^MUSICAL SYMBOL COMBINING FLAG-/}
]
# 6.1.0 Added HANGUL SINGLE DOT TONE MARK..HANGUL DOUBLE DOT TONE MARK
# 7.0 Added AA7D
# 10.0 Added 1CF7 (similar to 1CE1)
\p{Alphabetic} ⊇ [\p{GC=Lu} \p{GC=Ll} \p{GC=Lt} \p{GC=Lm} \p{GC=Lo} \p{GC=Nl} \p{GC=Mc} - $AlphaExclusions]

# Show [\p{GC=Mc} - \p{alphabetic}]
# Show [\p{GC=Mc} & \p{alphabetic}]


\p{Whitespace} ⊃ [\p{GC=Zs} \p{GC=Zp} \p{GC=Zl}]
\p{GC=Zs} ≉ \p{Name=/SPACE/}

\p{Dash} ⊃ [\p{GC=Pd}]

\p{Script=Common} ∥ [\p{GC=Mn} \p{GC=Me} \p{Join_Control}]
\p{Script=Inherited} ⊆ [\p{GC=Mn} \p{GC=Me} \p{Join_Control}]
\p{Script=Unknown} = [\p{GC=Cn} \p{GC=Co} \p{GC=Cs}]

Show [\u20b9]

# [\p{Alphabetic}] ∥ \p{Script=Common}
#  & [\p{Decomposition_Type=None} \p{Decomposition_Type=Canonical}]

## Alphabetic, Diacritic, and Extender.

# Consistency with Indic_Syllabic_Category.

# The UTC 172 script ad hoc report (L2/22-128) item VII 27 “Nonalphabetic bindus” points out that
# “Most characters with InSC=Bindu have Alphabetic=Yes”
# and adjustments have been made so that all current bindus have Alphabetic=Yes.
# The check below enforces that rule, but allows for possible future
# exceptions. Should such exceptions arise, they can be added to the definition of
# $nonAlphabeticBindus to avoid a failure on this test.
Let $nonAlphabeticBindus := []
[\p{InSc=Bindu} - \p{Alphabetic}] = $nonAlphabeticBindus

Let $nonAlphabeticDependentVowels := [
    \N{ORIYA SIGN OVERLINE}
    \N{THAI CHARACTER MAITAIKHU}
    \N{LIMBU SIGN KEMPHRENG}
    \N{SHARADA VOWEL MODIFIER MARK}
    \N{SHARADA EXTRA SHORT VOWEL MARK}
]
[\p{InSC=Vowel_Dependent} - \p{Alphabetic}] = $nonAlphabeticDependentVowels

# Several invariants from L2/24-009 item 2.2.
\p{InSC=Gemination_Mark} ⊆ \p{Extender}
\p{InSC=Nukta} ⊆ \p{Diacritic}
[\p{InSC=Virama}\p{InSC=Pure_Killer}\p{InSC=Reordering_Killer}] ⊆ \p{Diacritic}
\p{InSC=Invisible_Stacker} ⊆ \p{Diacritic}
Let $nonAlphabeticAvagrahas := [\N{TIBETAN MARK PALUTA}]  # A punctuation mark.
[\p{InSC=Avagraha} - $nonAlphabeticAvagrahas] ⊆ \p{Alphabetic}

# Name-based checks.
Let $nonLowercaseSmallLetters := [
    \p{name=/^LIMBU SMALL LETTER/}
    \N{TURNED GREEK SMALL LETTER IOTA}
    \p{name=/^(SQUARED|PARENTHESIZED|TAG) LATIN SMALL LETTER/}
]
Let $nonLowercaseSmallModifierLetters := [ \p{gc=Lm} & \p{name=/^ARABIC SMALL/} ]
[ \p{name=/\bSMALL LETTER\b/}-\p{gc=Mn}-\p{gc=Lt} - $nonLowercaseSmallLetters ] ⊆ \p{Lowercase}
[ [\p{gc=Lm} & \p{name=/SMALL/}] - $nonLowercaseSmallModifierLetters ] ⊆ \p{Lowercase}

# Combining letters are often alphabetic (medievalist abbreviations).
# The others are diacritic (cantillation marks, phonetics).
# See 177-C52.
\p{name=/COMBINING .* LETTER/} ⊆ [\p{Alphabetic}\p{Diacritic}]

## Consistency of Lowercase with decompositions.
# Note that the same is not true of Uppercase.
# A non-lowercase character has non-lowercase characters in its decomposition,
# or its decomposition is <square> (㋍ etc.).
In [\P{Lowercase} - \p{dt=square}], \p{Lowercase} * toNFKD ≠ toNFKD

## Joining_Type and Joining_Group
# Where defined, the Joining_Group refines the Joining_Type.
OnPairsOf \P{Joining_Group=No_Joining_Group}, EqualityOf Joining_Group ⇒ EqualityOf Joining_Type
\p{gc=Mn} ⊆ \p{Joining_Type=Transparent}
\p{gc=Me} ⊆ \p{Joining_Type=Transparent}

# Derivation of Joining_Type from the second column of ArabicShaping.txt (unofficially Other_Joining_Type).
In \P{Other_Joining_Type=Deduce_From_General_Category}, Joining_Type = Other_Joining_Type
[ \p{Other_Joining_Type=Deduce_From_General_Category} & [\p{gc=Mn}\p{gc=Me}\p{gc=Cf}] ] ⊆ \p{Joining_Type=Transparent}
[ \p{Other_Joining_Type=Deduce_From_General_Category} - [\p{gc=Mn}\p{gc=Me}\p{gc=Cf}] ] ⊆ \p{Joining_Type=Non_Joining}

## Modifier_Combining_Mark stability.
In \P{U-1:gc=Cn}, Modifier_Combining_Mark = U-1:Modifier_Combining_Mark

##########################
# LineBreak property
##########################

Let $IDInclusions := [
    [:block=/Ideographs/:]
    [  # Some ranges default to lb=ID even outside of any blocks:
        [\U00020000-\U0003FFFF]  # Planes 2 and 3, lb=ID since 5.2, 115-C27.
        [\U0001F000-\U0001FFFF]  # SMP range lb=ID by default since 9.0, 147-C25,
        - [                      # with exceptions:
              [:block=Symbols for Legacy Computing:]  # since 13.0, 162-A67;
              [:block=Supplemental Arrows C:]         # since 16.0, 177-C47.
          ]
    ] & [:gc=Cn:] - [:NChar:]
]
\p{LB=ID} ⊃ $IDInclusions
\p{Line_Break=Unknown} = [
      \p{General_Category=Unassigned} \p{GeneralCategory=PrivateUse}
    - $IDInclusions
    - [\u20C0-\u20CF]  # Unassigned currency symbols are lb=PR since 6.3, 133-C26.
]

Let $BrahmicLineBreaking := [
    \p{sc=Balinese}
    \p{sc=Batak}
    \p{sc=Brahmi}
    \p{sc=Cham}
    \p{sc=DivesAkuru}
    \p{sc=Grantha}
    \p{sc=Javanese}
    \p{sc=Makasar}
    \p{sc=Kawi}
    \p{sc=Cham}
    \p{sc=Makasar}
    \p{sc=Tulu_Tigalari}
    \p{sc=Gurung_Khema}
]
Let $VFScripts := [\p{sc=Batak}]

Let $OPInclusions := [\u00A1\u00BF\u2E18\U00013258-\U0001325A\U00013286\U00013288\U00013379\U0001342F\U00013437\U0001343C\U0001343E\U000145CE\U0001E95E-\U0001E95F]
# 7.0 Removed hack  - [\u2308\u230A]
# 9.0 Added Adlam initial punctuation 1E95E..1E95F
# 12.0 Added Egyptian control begin segment 13437 (gc=Cf, lb=OP)
# 15.0 Added Egyptian control begin enclosure 1343C, begin walled enclosure 1343E (gc=Cf, lb=OP)
# 15.1 UTC AI 173-A9: Change the Line_Break value of U+1342F EGYPTIAN HIEROGLYPH V011D from AL to OP.

\p{LB=OP} = [\p{GC=Ps} $OPInclusions]
[\p{LB=CL}\p{LB=CP}] ⊃ [\p{GC=Pe} - [\u2309\u230B]]

# See L2/22-086 for an explanation of the special case of Batak.
# (Note that Consensus 177-C43 changed the Batak viramas from InSC=Pure_Killer to Reordering_Killer.)
\p{LB=VI} = [[\p{Indic_Syllabic_Category=Virama}\p{Indic_Syllabic_Category=Invisible_Stacker}] & $BrahmicLineBreaking]
\p{LB=VF} = [\p{Indic_Syllabic_Category=Reordering_Killer} & $VFScripts]

\p{LB=CM} = [
      [\u3035] \p{GC=Mn} \p{GC=Me} \p{GC=Mc} \p{GC=Cc} \p{GC=Cf}
    - [\U00013437\U00013438\U0001343C-\U0001343F]  # Egyptian controls begin/end segment etc. (gc=Cf, lb=OP/CL)
    - \p{LB=SA} - \p{LB=WJ} - \p{LB=ZW} - \p{LB=BA}
    - \p{LB=LF} - \p{LB=BK} - \p{LB=CR} - \p{LB=NL}
    - \p{LB=GL} - \p{LB=AL} - \p{LB=ZWJ}
    - \p{LB=VI} - \p{LB=VF}
    - \p{LB=NU}  # 176-A81 changed [[:PCM:]-\u070F] from lb=AL to lb=NU
]

#  3.0.0: Numeric characters consist of decimal digits (all characters of General_Category Nd),
#         except those with East_Asian_Width F (Fullwidth)
# 15.1.0: and those from scripts that use the Brahmic style of context analysis,
#  4.0.1: plus these characters: 066B ARABIC DECIMAL SEPARATOR, 066C ARABIC THOUSANDS SEPARATOR.
# 15.1.0: Action item UTC-176-A81: change [[:PCM:]-\u070F] lb=AL->NU
# 16.0.0: UTC-180-A54: U+19DA from lb=SA to lb=NU.
Let $NUInclusions := [\u066B\u066C\u19DA]
Let $NUFormats := [[:PCM:]-[\u070F]]
\p{LB=NU} = [\p{GC=Nd} $NUInclusions $NUFormats - \p{EA=F} - $BrahmicLineBreaking]

# Digits are lb=AS in scripts with brahmic line breaking.
[\p{GC=Nd} & $BrahmicLineBreaking] ⊆ \p{LB=AS}

# Batak is the one case where assigning LB=AS to digits could lead to unexpected results, because
# of the rule (AK | ◌ | AS) × (AK | ◌ | AS) VF.  There are no Batak digits.
[\p{GC=Nd} & $VFScripts] = []

Let $PRInclusions := [\u002b\u005c\u00b1\u2116\u2212\u2213\u20C0-\u20CF]
\p{LB=PR} = [\p{GC=Sc} $PRInclusions - \p{LB=PO}]

Let $QUInclusions := [\u275F-\u2760 \U0001F676-\U0001F678 \u0022 \u0027 \u275B-\u275E \u2E00-\u2E01 \u2E06-\u2E08 \u2E0B]
# 7.0 added 275F..2760 1F676..1F678
\p{LB=QU} = [\p{GC=Pf} \p{GC=Pi} $QUInclusions]
\p{LB=SG} = \p{GC=Cs}
\p{LB=SP} = [\N{SPACE}]
\p{LB=SY} = [\N{SOLIDUS}]

# The classes WJ and ZW are reserved for characters meant as explicit overrides
# to the line breaking algorithms.  For historical reasons, WJ has two such
# characters, see L2/00-258.
# These invariants should not change unless a change to the overrides is being
# considered.  In particular, ordinary characters whose joining or shaping
# behaviour requires the prohibition of line breaks on either side should have
# class GL.
\p{LB=WJ} = [\N{WORD JOINER} \N{ZERO WIDTH NO-BREAK SPACE}]
\p{LB=ZW} = [\N{ZERO WIDTH SPACE}]

\p{LB=ZWJ} = [\u200D]
\p{LB=RI} = \p{RI=Y}


# A few southeast Asian scripts allow line breaks only at word boundaries,
# but do not mark word boundaries in any way, so that the
# determination of line break opportunities requires language dependent text analysis.
# In terms of UAX #14, these scripts need the “South East Asian” style of context analysis for
# line breaking, and their characters are given lb=SA (Line_Break=SA: complex context dependent)
# as an escape out of the rule-based algorithm in UAX #14.
#
# For these scripts, test the following invariant:
# 
# Add all characters that have an explicit Script property value from among the
# set of scripts known to use Line_Break=SA values to the set $SAScripts. Then
# the intersection of the $SAScripts set with the set of characters whose Line_Break
# values are either LineBreak=SA or LineBreak=CM should always be
# identical to the intersection of the $SAScripts set with the set of characters
# which are Alphabetic=True or whose General_Category values are General_Category=Cf
# or General_Category=Mn. 
# 
# Exceptional cases for which characters in $SAScripts have LineBreak=SA but
# where those characters are non-alphabetic or have General_Category other
# than Cf or Mn (such as General_Category=No numerical characters) are
# covered by adding them to the exception set $SAScriptExceptions for the test.

# SA are limited to certain scripts:
Let $SAScripts := [
    \p{script=ahom}
    \p{script=thai}
    \p{script=lao}
    \p{script=myanmar}
    \p{script=khmer}
    \p{script=Tai_Le}
    \p{script=New_Tai_Lue}
    \p{script=Tai_Tham}
    \p{script=Tai_Viet}
]
$SAScripts ⊇ \p{LineBreak=SA}

# And in $SA scripts, they are all the alphabetic spacing characters, plus some odd Cf & Mn
Let $SAScriptExceptions := [\x{1173A}\x{1173B}\x{1173F} \u109E\u109F\u19DE\u19DF\u1AA0-\u1AA6\u1AA8-\u1AAD\uAA77-\uAA79\uAADE-\uAADF]
# 7.0 Added AA7D
# 12.0 Removed Myanmar spacing marks which were assigned Other_Alphabetic: 1063..1064, 1069..106D, 1087..108C, 108F, 109A..109B, AA7B, AA7D

[$SAScripts & [\p{Alphabetic} \p{gc=cf} \p{gc=Mn} $SAScriptExceptions]] = [$SAScripts & [\p{LineBreak=SA} \p{LineBreak=CM}]]

# Make sure there are not redundancies in the $SAScriptExceptions. These are not formally a problem, but make the test cleaner

$SAScriptExceptions ∥ [\p{Alphabetic} \p{gc=cf} \p{gc=Mn}]

##########################
# Word Break
##########################

# 6.0: Compare word characters with similar identifier characters

# UAX 31 Table 3: Candidate Characters for Inclusion in Identifiers
# Warning: the uax31 tables don't have machine-readable tables, so must be updated each release.
Let $uax31table3 := [\u0027\u002D\u002E\u003A\u00B7\u058A\u05F3\u05F4\u0F0B\u200C\u200D\u2010\u2019\u2027\u30A0\u30FB]

Let $WBRemovals := [\u0387\u0604\u2018\u2024\u202F\u2E2F\uFE13\uFE52\uFE55\uFF07\uFF0E\uFF1A\u200c\u200d'.\:\u00AD\u00B7\u05F3\u05F4\u0600-\u0603\u06DD\u070F\u17B4\u17B5\u200E\u200F\u2019\u2027\u202A-\u202E\u2060-\u2064\u206A-\u206F\uFEFF\uFFF9-\uFFFB\u02C2-\u02C5\u02D2-\u02D6\u02DE-\u02DF\u02ED\u02EF-\u02FF\uA720-\uA721\uA789-\uA78A\uAB5B\u055B\u055C\u055E\U000110BD\U0001D173-\U0001D17A\U000E0001\U000E0020-\U000E007F\p{gc=Cf}\p{Block=Enclosed Alphanumerics}[\u02D7\u0605\u061C\u180E\u2066-\u2069\U0001BCA0-\U0001BCA3\U0001F130-\U0001F149\U0001F150-\U0001F169\U0001F170-\U0001F189\U0001F3FB-\U0001F3FF]]
Let $WBRemovals13 := [\u02E5-\u02EB\u055A\u058A\uA708-\uA716\u055F]
# 9.0 corrected \p{gc=Cf} and added 202F
# 10.0 added 34 characters which were absorbed into WB=LE (see http://www.unicode.org/reports/tr29/tr29-30d2.html#ALetter)
# 11.0 added 5 skin tone modifiers which were absorbed into WB=Extend
# 11.0 added 3 Armenian punctuation marks which were absorbed into WB=LE (see http://www.unicode.org/L2/L2018/18115.htm#155-C3)
# 13.0 added 24 characters (mostly tone modifiers) which were absorbed into WB=LE (see http://www.unicode.org/reports/tr29/tr29-36.html#ALetter)
# 13.0 added 055F which was absorbed into WB=ML (see http://www.unicode.org/reports/tr29/tr29-36.html#MidLetter)

Let $Uax31Removals := [\-\u058A\u0F0B\u2010\u30A0\u30FB\u2E2F\u17B4-\u17B5]
# 6.1.0 adjust SAMVAT, KHMER VOWEL INHERENT*

[\p{Alpha}\p{WB=Extend}\p{WB=FO}\p{WB=LE}\p{WB=ML}\p{WB=MB}\p{WB=EX}-$WBRemovals-$WBRemovals13] = [$gcAllLetters $gcAllMarks \p{gc=Nl}\p{gc=Pc}-$Uax31Removals]

# Don’t break words after GCB=Prepend characters (that would be within a
# grapheme cluster).
# GCB=Prepend should not be WB=Format, PRI469 [Fri Jan 6 18:26:42 CST 2023].
# We prevent that by excluding GCB=Prepend from Format.
# We need to make sure that we remember to put them somewhere else appropriate
# for their usage, so we check that they are not left in WB=Other.
[\p{GCB=Prepend}&\p{WB=Format}] = []
[\p{GCB=Prepend}&\p{WB=Other}] = []

##########################
# Derivations
##########################

\p{Math} = [\p{Other_Math} \p{GC=Sm}]
\p{Alphabetic} = [\p{Other_Alphabetic} \p{GC=Lu} \p{GC=Ll} \p{GC=Lt} \p{GC=Lm} \p{GC=Lo} \p{GC=Nl}]
\p{Lowercase} = [\p{Other_Lowercase} \p{GC=Ll}]
\p{Uppercase} = [\p{Other_Uppercase} \p{GC=Lu}]
\p{ID_Start} = [\p{Other_ID_Start} \p{GC=Lu} \p{GC=Ll} \p{GC=Lt} \p{GC=Lm} \p{GC=Lo} \p{GC=Nl} - \p{Pattern_Syntax} - \p{Pattern_White_Space}]
\p{ID_Continue} = [\p{Other_ID_Continue} \p{ID_Start} \p{GC=Mn} \p{GC=Mc} \p{GC=Nd} \p{GC=Pc} - \p{Pattern_Syntax} - \p{Pattern_White_Space}] 

# See derivation of Default_Ignorable_Code_Point in DerivedCoreProperties.txt
Let $Annotations := [\uFFF9-\uFFFB]
Let $EgyptianControls := [\U00013430-\U00013440]
\p{Default_Ignorable_Code_Point} = [\p{Other_Default_Ignorable_Code_Point} \p{GC=Cf} \p{Variation_Selector} - [\p{White_Space} $Annotations $EgyptianControls \p{PCM}]]

\p{Grapheme_Extend} = [\p{Other_Grapheme_Extend} \p{GC=Me} \p{GC=Mn}]

\p{Grapheme_Base} = [^\p{GC=Cc} \p{GC=Cf} \p{GC=Cs} \p{GC=Co} \p{GC=Cn} \p{GC=Zl} \p{GC=Zp} \p{Grapheme_Extend}]
\p{Grapheme_Link} = \p{CCC=Virama}

# "Minimal" Other_: NOT hard requirements; just if we want to be minimal
# (Should add way to make these warnings, not errors)

\p{Other_Math} = [\p{Math} - \p{GC=Sm}]
\p{Other_Alphabetic} = [\p{Alphabetic} - [\p{GC=Lu} \p{GC=Ll} \p{GC=Lt} \p{GC=Lm} \p{GC=Lo} \p{GC=Nl}]]
\p{Other_Lowercase} = [\p{Lowercase} - \p{GC=Ll}]
\p{Other_Uppercase} = [\p{Uppercase} - \p{GC=Lu}]
\p{Other_ID_Start} = [\p{ID_Start} - [\p{GC=Lu} \p{GC=Ll} \p{GC=Lt} \p{GC=Lm} \p{GC=Lo} \p{GC=Nl} - \p{Pattern_Syntax} - \p{Pattern_White_Space}]]
\p{Other_ID_Continue} = [\p{ID_Continue} - [\p{ID_Start} \p{GC=Mn} \p{GC=Mc} \p{GC=Nd} \p{GC=Pc} - \p{Pattern_Syntax} - \p{Pattern_White_Space}]]

\p{Other_Default_Ignorable_Code_Point} = [\p{Default_Ignorable_Code_Point} - [\p{GC=Cf} \p{Variation_Selector} - [\p{White_Space} $Annotations]]]
\p{Other_Grapheme_Extend} = [\p{Grapheme_Extend} - [\p{GC=Me} \p{GC=Mn}]]

\p{GCB=Prepend} = [\p{InSC=Consonant_Preceding_Repha} \p{InSC=Consonant_Prefixed} \p{PCM}]
\p{GCB=Extend} = [\p{Grapheme_Extend} \p{Emoji_Modifier}]
# 11.0: GCB=Extend is no longer identical to Grapheme_Extend=Y
\p{WB=Extend} = [\p{Grapheme_Extend} \p{GC=Mc} [\U0001F3FB-\U0001F3FF] - [\u200D]]
# 11.0: skin tone modifiers were absorbed into WB=Extend
\p{SB=Extend} = [\p{Grapheme_Extend} \p{GC=Mc} \u200D]

\p{RI=Y} = [\p{GCB=RI}]
\p{RI=Y} = [\p{WB=RI}]

# Post-base spacing combining marks (gc=Mc, InPC=Right) of certain SE Asian scripts
# are explicitly excluded from GCB=SpacingMark, and instead should fall through to GCB=XX.
# This allows to position cursors inside clusters.
# See https://www.unicode.org/reports/tr29/#SpacingMark
# When this test case fails, then
# either adjust the set of scripts, or
# - change ToolUnicodePropertySource.java to remove the offending characters from the gcbSpacingMarkSet
# - add them to the exceptions list in UAX #29
Let $PostBaseSpacingMarks_All := [[:sc=Myanmar:][:sc=Tai_Tham:][:sc=Ahom:] & [:gc=Mc:] & [:InPC=Right:]]
Let $PostBaseSpacingMarks_Tweak := [\u103B \u1056 \u1057 \u1A57 \u1A6D]
Let $PostBaseSpacingMarks_Missed := []
[$PostBaseSpacingMarks_All - $PostBaseSpacingMarks_Tweak - $PostBaseSpacingMarks_Missed] ⊂ [:GCB=XX:]

# Check the consistency of grapheme cluster segmentation (both legacy and
# extended) with canonical equivalence.
# Non-starters are GCB=Extend or GCB=SpacingMark, so that GB9 and GB9a keep
# together any sequences that may be reordered by the Canonical Ordering
# Algorithm.  This has been true ever since Extended Grapheme Clusters were
# added.
\P{U5.1.0:ccc=0} ⊆ [\p{U5.1.0:GCB=Extend}\p{U5.1.0:GCB=SpacingMark}]
\P{ccc=0} ⊆ [\p{GCB=Extend}\p{GCB=SpacingMark}]
# Non-starters are actually GCB=Extend, so that GB9 alone does the job, since
# there is no GB9a in legacy grapheme clusters.
# But not before Unicode Version 16.0, even though we were saying so since
# Unicode Version 4.0 (https://www.unicode.org/reports/tr29/tr29-4.html#Implementation_Notes),
# oops (see L2/24-009).
Let $TwoForgottenMusicalSymbols := \p{Name=/^MUSICAL SYMBOL COMBINING (SPRECHGESANG STEM|AUGMENTATION DOT)$/}
Let $FourteenSpacingViramas := [\p{U15.1.0:ccc=9}&\p{U15.1.0:gc=Mc}]
Let $TwoVietnameseReadingMarks := [\p{U15.1.0:ccc=6}]
[\P{U4.0.0:ccc=0}  - \p{U4.0.0:Grapheme_Extend}] = [$TwoForgottenMusicalSymbols
                                                    \p{Name=/^MUSICAL SYMBOL COMBINING FLAG-[3-5]$/}]
[\P{U4.1.0:ccc=0}  - \p{U4.1.0:GCB=Extend}]      = $TwoForgottenMusicalSymbols
[\P{U15.1.0:ccc=0} - \p{U15.1.0:GCB=Extend}]     = [$TwoForgottenMusicalSymbols
                                                    $FourteenSpacingViramas
                                                    $TwoVietnameseReadingMarks]
 \P{        ccc=0} ⊆ \p{        GCB=Extend}

# Characters that appear in non-initial position in the canonical decomposition
# of another character are either Extend, V, or T, so that sequences that are
# equivalent to a canonical composite are kept together by GB6..GB9.
# We only look at the starters, since we dealt with non-starters above.
# Characters that appear in non-initial position in the canonical decomposition
# of a primary composite are NFC_QC=Maybe.  We would need to separately check
# the characters that appear in non-initial position in the canonical
# decomposition of a full composition exclusion.
# We would also need to separately check that the characters are T or V only
# appear in canonical decompositions where they follow an LV, LVT, V, or T, or
# an LV or V, respectively.
[\p{NFC_QC=Maybe}&\p{ccc=0}] ⊆ [\p{GCB=Extend}\p{GCB=T}\p{GCB=V}]

# Canonical decomposition preserves the initial GCB, except for LV and LVT.
In [\p{dt=canonical}-[\p{gcb=LV}\p{gcb=LVT}]], gcb * (take 1) * dm = gcb
In [\p{gcb=LV}\p{gcb=LVT}], (take 1) * dm ∈ [\p{gcb=L} \p{gcb=LV} \p{gcb=LVT}]

# ICU relies on this to avoid carrying data for HST which would be mostly
# redundant with GCB.  If this breaks, it should be noted on the landing page,
# and ICU-TC should be notified.
# See https://github.com/unicode-org/icu/pull/3026.
\p{HST=V} = [\p{GCB=V} & [\u0000-\uFFFF]]
# A more principled (if less practically useful) statement is that the
# dual-conjoining Hangul characters are exactly the Hangul vowels.
\p{HST=V} = [\p{GCB=V} & \p{Script=Hangul}]
# The other types are still straightforwardly related to their GCB counterparts.
\p{HST=L}   = \p{GCB=L}
\p{HST=LV}  = \p{GCB=LV}
\p{HST=LVT} = \p{GCB=LVT}
\p{HST=T}   = \p{GCB=T}

##########################
# Emoji
##########################

\p{RI} ⊂ \p{Emoji_Component}
\p{Emoji_Modifier} ⊂ \p{Emoji_Component}
\p{Emoji_Component} ≉ \p{Emoji}
\p{Emoji_Modifier_Base} ⊂ \p{Emoji}
\p{Emoji_Modifier} ⊂ \p{Emoji_Presentation}
\p{Emoji_Presentation} ⊂ \p{Emoji}

Let $HairComponents := [\U0001F9B0-\U0001F9B3]
[\p{Extended_Pictographic} & \p{Emoji_Component}] = $HairComponents
\p{Extended_Pictographic} ⊃ [\p{Emoji} - \p{Emoji_Component}]
\p{Extended_Pictographic} ⊃ [\p{Emoji_Presentation} - \p{Emoji_Component}]

# lb=EB:
# https://www.unicode.org/reports/tr14/#EB
# "This class directly corresponds to the Emoji_Modifier_Base property"
\p{lb=EB} = \p{Emoji_Modifier_Base}

# lb=EM:
# https://www.unicode.org/reports/tr14/#EM
# "This class directly corresponds to the Emoji_Modifier property"
\p{lb=EM} = \p{Emoji_Modifier}

# Recent pictographs with default emoji presentation are lb=ID, EB or EM:
[\p{Emoji_Presentation} & [\p{age=7.0}\p{age=8.0}\p{age=9.0}\p{age=10.0}\p{age=11.0}\p{age=12.0}\p{age=13.0}\p{age=14.0}\p{age=15.0}]] ⊂ [\p{lb=ID} \p{lb=EB} \p{lb=EM}]

[\p{Emoji_Presentation} - \p{RI}] ⊂ \p{ea=W}

\p{RGI_Emoji_Zwj_Sequence} ⊃ []
\p{RGI_Emoji_Zwj_Sequence} ⊇ \p{U-1:RGI_Emoji_Zwj_Sequence}
# Unicode Version 15.1 had no new emoji code points, but had ZWJ sequences.
\p{U15.1:RGI_Emoji_Zwj_Sequence} ⊃ \p{U15:RGI_Emoji_Zwj_Sequence}
\p{U15.1:Emoji} = \p{U15:Emoji}
[\p{U15.1:RGI_Emoji_Zwj_Sequence} - \p{U15:RGI_Emoji_Zwj_Sequence}] ⊃ [{🐦‍🔥}]
# Likewise Emoji Version 13.1
# (which was not actually a Unicode version, so we cannot look at U13.1:Emoji).
\p{U13.1:RGI_Emoji_Zwj_Sequence} ⊃ \p{U13:RGI_Emoji_Zwj_Sequence}
[\p{U13.1:RGI_Emoji_Zwj_Sequence} - \p{U13:RGI_Emoji_Zwj_Sequence}] ⊃ [{😵‍💫}]

##########################
# POSIX Compatibility Properties (UTS#18)
# http://www.opengroup.org/onlinepubs/007904975/basedefs/xbd_chap07.html
##########################

# constants

Let $SP := [\u0020]	# [\N{space}]
Let $TAB := [\u0009] # [\N{CHARACTER TABULATION}]
Let $LF := [\u000A]	# \N{linefeed}
Let $VTAB := [\u000B]	# [\N{LINE TABULATION}]
Let $FF := [\u000C]	# [\N{formfeed}]
Let $CR := [\u000D]	# \N{carriage return}
Let $NEL := [\u0085]	# \N{next line}
#Let $ZWNJ = [\u200C]	# [\N{ZERO WIDTH NON-JOINER}]
#Let $ZWJ = [\u200D]	# [\N{ZERO WIDTH JOINER}]

Let $CircledAsciiLetters := [\u24B6-\u24E9]

# Unassigned, Control, Format, Private_Use, Surrogate, 
# Uppercase_Letter, Lowercase_Letter, Titlecase_Letter, Modifier_Letter, Other_Letter,
# Nonspacing_Mark, Enclosing_Mark, Spacing_Mark,
# Decimal_Number, Letter_Number, Other_Number, 
# Space_Separator, Line_Separator, Paragraph_Separator, 
# Dash_Punctuation, Open_Punctuation, Close_Punctuation, Connector_Punctuation, Other_Punctuation, Initial_Punctuation, Final_Punctuation
# Math_Symbol, Currency_Symbol, Modifier_Symbol, Other_Symbol

# UTS Rules

Let $alpha := [\p{Alphabetic} $CircledAsciiLetters]
Let $lower := \p{Lowercase} 
Let $upper := [\p{Uppercase}]
Let $punct := [$gcAllPunctuation $gcAllSymbols - $alpha]
Let $digit := \p{gc=Decimal_Number} 
Let $xdigit := [\p{gc=Decimal_Number} \p{Hex_Digit}] # in both!
Let $alnum := [$alpha $digit]
Let $space := \p{Whitespace} 
Let $blank := [\p{Whitespace} - [$LF $VTAB $FF $CR $NEL \p{gc=Line_Separator} \p{gc=Paragraph_Separator}]]
Let $cntrl := \p{gc=Control} 
Let $graph := [^$space \p{gc=Control} \p{gc=Surrogate} \p{gc=Unassigned}]
Let $print := [$graph $blank - $cntrl]
Let $word := [$alpha $gcAllMarks $digit \p{gc=Connector_Punctuation}] 

# ===========================

# POSIX locale definition file constraints

$upper ∥ [$cntrl $digit $punct $space]
$upper ⊇ [A-Z]

$lower ∥ [$cntrl $digit $punct $space]
$lower ⊇ [a-z]

$alpha ∥ [$cntrl $digit $punct $space]
$alpha ⊇ [$lower $upper]

$digit ⊇ [0-9]

$alnum = [$alpha $digit]

$space ∥ [$upper $lower $alpha $digit $graph $xdigit]
$space ⊇ [$SP $FF $LF $CR] # $TAB $VTAB $NEL]
$space ⊇ $blank

$cntrl ∥ [$upper $lower $alpha $digit $punct $graph $print $xdigit]

$punct ∥ [$upper $lower $alpha $digit $cntrl $xdigit $SP]

$graph ⊇ [$upper $lower $alpha $digit $xdigit $punct]
$graph ∥ [$SP $cntrl]

$print ⊇ [$upper $lower $alpha $digit $xdigit $punct $graph $SP]
$print ∥ $cntrl

$xdigit ⊇ [$digit [a-f A-F]]

$blank ⊇ [$SP $TAB]

# Extra POSIX 'POSIX locale' constraints

Let $C0Controls := [\u0000-\u001F]

$cntrl ⊇  $C0Controls

$punct  ⊇ [[\u0021-\u007E] - [0-9 A-Z a-z]]

[$alpha $lower $upper $punct $digit $xdigit $alnum $space $blank $cntrl $graph $print $word] = [^\p{gc=unassigned} \p{gc=surrogate}]

# Map tests

# Verify that the mappings in Case_Folding for the old characters
# are the same as the previous version's.
# TODO: Update the versions each time.
# TODO: Make the UnicodeMapParser understand versioned properties (and \P not just \p)
# so that we can intersect the left side with \P{U-1:gc=Cn}
# (assigned characters in the previous version) for automatic updates.
# BUG: It looks like \p{age=13.0} includes only the characters *added new* in 13.0,
# not also all of the earlier ones.
# We should be able to use:
# Map {\m{Case_Folding}&\P{U-1:gc=Cn}} = {\m{*Case_Folding}]}

# Commented out because excruciatingly slow, and tested systematically above with an In line.
# TODO(macchiati): Make this faster.
# Map {\m{Case_Folding}&[^\p{age=14.0}]} = {\m{*Case_Folding}&[^\p{age=14.0}]}

# The following are 'red flag' tests, just so that we review the changes and make sure they are ok.

# Ideographic invariants

# The Khitan Small Script filler is a Nonspacing Mark.
# The other characters are numerals (the Hangzhou ten through thirty are compatibility decomposable,
# but not the one through nine) and have Script=Han.
Let $NonOtherLetterIdeographs := [\N{KHITAN SMALL SCRIPT FILLER}  〇 〡-〩 〸-〺]
$NonOtherLetterIdeographs = [\p{Ideographic} - \p{gc=Lo}]
# Ideographic closing mark, gc=Lo.
Let $CommonIdeographs := [〆]
$CommonIdeographs = [\p{Ideographic} & \p{sc=Common}]

\p{Ideographic} = [
    $NonOtherLetterIdeographs $CommonIdeographs
    [
        \p{gc=Lo} & [
            \p{Script=Han}
            \p{Script=Tangut}
            \p{Script=Nushu}
            \p{Script=Khitan_Small_Script}
        ]
    ]
]

[ [\p{Ideographic}&\p{sc=Han}] - \p{nfkcqc=n} - $NonOtherLetterIdeographs ] = \p{Unified_Ideograph}

Let $unihanScope := [\p{Block=/^CJK.(Unified|Compatibility).Ideographs/} - \p{gc=Cn}]
\p{Unified_Ideograph} ⊂ $unihanScope
$unihanScope = [\p{gc=Lo} & \p{sc=Hani}]
$unihanScope = \P{kRSUnicode=@none@}
$unihanScope = \P{kTotalStrokes=@none@}
$unihanScope = [
    \P{kIRG_GSource=@none@}
    \P{kIRG_HSource=@none@}
    \P{kIRG_JSource=@none@}
    \P{kIRG_KPSource=@none@}
    \P{kIRG_KSource=@none@}
    \P{kIRG_MSource=@none@}
    \P{kIRG_SSource=@none@}
    \P{kIRG_TSource=@none@}
    \P{kIRG_UKSource=@none@}
    \P{kIRG_USource=@none@}
    \P{kIRG_VSource=@none@}
]

# TODO(eggrobin): Should those two have a kMandarin, or this not actually an invariant?
# See https://www.unicode.org/review/pri483/feedback.html#ID20240118004124.
# Change to \P{kHanyuPinyin=@none@} ⊆ \P{kMandarin=@none@} once this gets fixed.
Let $ideographsMissingkMandarin := [\x{228F5}\x{2574C}]
[\P{kHanyuPinyin=@none@} - \P{kMandarin=@none@}] = $ideographsMissingkMandarin

Let $cjkStrokes := \p{Name=/^CJK STROKE /}
Let $kangxiRadicals := \p{Name=/^KANGXI RADICAL /}
Let $cjkRadicals := \p{Name=/^CJK RADICAL /}
Let $strokesAndRadicals := [ $cjkStrokes $kangxiRadicals $cjkRadicals ]
Let $nonIdeographicRadicals := [\N{CJK RADICAL REPEAT}]
# The following set may expand over time, if strokes are added.
# It can also shrink, if single-stroke ideographs are encoded.
Let $nonIdeographicStrokes := \p{Name=/^CJK STROKE (T|WG|XG|BXG|SW|HZZ|HP|HZWG|SZWG|HZT|HZZP|HPWG|HZW|HZZZ|PG|Q|HXG|SZP)$/}

# See https://www.unicode.org/review/pri502/feedback.html#ID20240523095709.
$cjkStrokes ⊆ \p{scx=Hani}

# The Equivalent_Unified_Ideograph property is applicable to CJK strokes and radicals.
# Its value is a single unified ideograph.
\P{Equivalent_Unified_Ideograph=@none@} ⊆ $strokesAndRadicals
[$strokesAndRadicals - \P{Equivalent_Unified_Ideograph=@none@}] = [$nonIdeographicStrokes $nonIdeographicRadicals]
In \P{Equivalent_Unified_Ideograph=@none@}, Equivalent_Unified_Ideograph ∈ \p{Unified_Ideograph}

# Strokes are equivalent to single-stroke ideographs.
In [$cjkStrokes - $nonIdeographicStrokes], Equivalent_Unified_Ideograph ∈ \p{kTotalStrokes=1}

# Kangxi radicals are equivalent to those radicals with no residual strokes.
In $kangxiRadicals, Equivalent_Unified_Ideograph ∈ \p{kRSUnicode=/\.0/}
# Simplified radicals are equivalent to a simplified radical with no residual strokes.
# That is a Chinese simplified radical (kRSUnicode=n'.0) for Chinese simplified radicals, and a
# non-Chinese simplified radical (kRSUnicode=n''.0) otherwise.
# However, two of the simplified radicals are unifiable with their non-simplified counterparts,
# and are therefore equivalent to ideographs with kRSUnicode=n.0.
Let $radicalsWithUnifiableSimplifications := [角辶]
$radicalsWithUnifiableSimplifications ⊆ \p{kRSUnicode=/^[0-9]+\.0$/}
[$radicalsWithUnifiableSimplifications & \p{kRSUnicode=/^[0-9]+'\.0$/}] = []
Let $chineseSimplifiedRadicals := \p{Name=/CJK RADICAL (C-)?SIMPLIFIED/}
Let $japaneseSimplifiedRadicals := \p{Name=/CJK RADICAL J-SIMPLIFIED/}
In $chineseSimplifiedRadicals, Equivalent_Unified_Ideograph ∈ [\p{kRSUnicode=/^[0-9]+'\.0$/} $radicalsWithUnifiableSimplifications]
In $japaneseSimplifiedRadicals, Equivalent_Unified_Ideograph ∈ \p{kRSUnicode=/^[0-9]+''\.0$/}

# Tangut invariants

Let $tangutSourcesScope := [\p{Block=/^Tangut(.Supplement)?$/} - \p{gc=Cn}]
$tangutSourcesScope = [ [\p{gc=Lo} & \p{sc=Tangut}] - \p{name=/^TANGUT COMPONENT-/} ]
$tangutSourcesScope = \P{kTGT_MergedSrc=@none@}
$tangutSourcesScope = \P{kRSTUnicode=@none@}

# Nüshu invariants

Let $nüshuSourcesScope := [\p{Block=Nushu} - \p{gc=Cn}]
$nüshuSourcesScope = [\p{gc=Lo} & \p{sc=Nushu}]
$nüshuSourcesScope = \P{kSrc_NushuDuben=@none@}
$nüshuSourcesScope = \P{kReading=@none@}

# Egyptian hieroglyph invariants

Let $unikemetScope := [\p{Block=/^Egyptian.Hieroglyphs/} - \p{gc=Cn}]
$unikemetScope = [ [\p{gc=Lo} & \p{sc=Egyp}] - \p{Name=/^EGYPTIAN HIEROGLYPH (FULL |HALF |TALL |WIDE )?(BLANK|LOST SIGN)$/} ]
$unikemetScope = \P{kEH_Cat=@none@}
$unikemetScope = \P{kEH_UniK=@none@}
$unikemetScope ⊃ \P{kEH_Core=None}
\p{kEH_NoMirror} ⊂ $unikemetScope
\p{kEH_NoRotate} ⊂ $unikemetScope
\p{kEH_Core=Legacy} ⊂ \p{Block=Egyptian Hieroglyphs}
[\p{kEH_Core=None} & $unikemetScope] ⊂ \p{Block=Egyptian Hieroglyphs Extended-A}

# InPC-InSC-gc invariants
# See https://www.unicode.org/L2/L2023/23200-category-invariants.pdf.
\p{InPC=/(Left|Right)/} ⊆ [\p{gc=Mc}\p{gc=Lo}\p{gc=Lm}]
[\P{InPC=NA}&\p{gc=Mc}] ⊆ \p{InPC=/(Left|Right)/}
[\P{InPC=NA}&\P{InPC=/(Left|Right)/}] ⊆ [\p{gc=Mn}\p{gc=Lo}]
\p{gc=Mn} ⊆ \P{InPC=/(Left|Right)/}
[\p{gc=Lo}&\P{InPC=NA}&\P{InPC=/(Left|Right)/}] ⊆ [\p{InSC=Consonant_Preceding_Repha}\p{InSC=Consonant_Prefixed}]

# Script Extensions (mostly testing the proper handling of multivalued properties).
\p{sc=Deva} ⊂ \p{scx=Deva}
[\p{scx=Deva} & \p{scx=Beng}] ⊃ []

# DoNotEmit.txt.
\p{Do_Not_Emit_Type=Deprecated} ⊆ \p{Deprecated}
\p{Deprecated} ⊆ [\p{Do_Not_Emit_Type=Deprecated} \p{Do_Not_Emit_Type=@none@}]
# The non-DI deprecated characters have replacements in DoNotEmit, except the angle brackets that
# are ambiguous.
\p{Do_Not_Emit_Type=Deprecated} = [ \p{Deprecated} - \p{Default_Ignorable_Code_Point} - \p{Name=/^(LEFT|RIGHT)-POINTING ANGLE BRACKET$/} ]

# Hangul Syllable Name Generation,
# https://www.unicode.org/versions/latest/ch03.pdf#G59675.
In [\p{Block=Hangul Syllables} - \p{gc=Cn}], (prepend HANGUL SYLLABLE ) * (string-join) * Jamo_Short_Name * toNFD = Name

# The Bidi Class of <font> compatibility decomposables is consistent with their “generic”
# counterpart.  Could be, but so far need not be, restricted to the intersection with \p{Math}.
# Inspired by, and would have caught,
# https://www.unicode.org/review/pri497/feedback.html#ID20240216135149.
In \p{Decomposition_Type=font}, Bidi_Class = Bidi_Class * Decomposition_Mapping

# Basic Propertywise tests.
Ignoring Name:

Propertywise [𐛪 𐛫] AreAlike

Ignoring Unicode_1_Name Confusable_MA:
    Propertywise [ي ۑ] AreAlike

    Propertywise [[β-ω] - [ς]] : [[Β-Ω] - \p{gc=Cn}]
    CorrespondTo [α]           :  [Α]

    Propertywise [[α-ω] - [ς]] : [[Α-Ω] - \p{gc=Cn}]
    CorrespondTo [g]           :  [G]
        UpTo: Block             (Greek_And_Coptic vs Basic_Latin),
              Script            (Greek            vs Latin),
              Script_Extensions (Greek            vs Latin),
              East_Asian_Width  (Ambiguous        vs Narrow)

    Propertywise [ʳʷʸ] : [rwy] : [RWY]
    CorrespondTo [ʰ]   : [h]   : [H]

    Ignoring Soft_Dotted:
        Propertywise [ʲ] : [j] : [J]
        CorrespondTo [ʰ] : [h] : [H]
    end Ignoring;

    # TODO(egg): Should ⁱ have Diacritic?  It is not its original intent, but
    # maybe it gets used that way too.
    Ignoring Block Age Diacritic:
        Propertywise [ʲ] : [j] : [J]
        CorrespondTo [ⁱ] : [i] : [I]
    end Ignoring;

    Propertywise [ゟ] ⧴ [{より}]
    CorrespondTo [ヿ] ⧴ [{コト}]
        UpTo: Block             (Hiragana vs Katakana),
              Script            (Hiragana vs Katakana),
              Script_Extensions (Hiragana vs Katakana),
              Word_Break        (Other    vs Katakana)

end Ignoring;

end Ignoring;