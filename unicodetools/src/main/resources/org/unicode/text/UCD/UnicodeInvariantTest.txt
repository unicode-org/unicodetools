# Invariance Tests
#
# This file provides a set of machine-readable invariance tests for Unicode Properties.
#
##########################
# Format
##########################
# Let <$variable> = <unicodeSet>
#  Assign a variable to a value. The variable must start with $.
#
# <unicodeSet> is a boolean combinations of properties and character ranges, as defined in LDML, 
#  with the following extensions.
#
#  Example:
#   [\p{General_Category=Unassigned}-[a-zA-Z]]
#
# Property Name:
#   <propertyName> can be the short or long form as in the PropertyAliases.txt
#   <propertyName> can be prefixed with "U<version>:"
#   Example: \p{U5.1.0:Whitespace}
#
#   A version of -1 indicates the previous released major version.
#   For example, if the version is 4.1, then the U-1 version is 4.0.
#   The property values are as supplied in the release, without any subsequent corrigenda being applied. 
#   Example: \p{U-1:Whitespace}
#
# Property Value:
#   If the propertyValue is missing, it is defaulted to true
#   If the value is of the form /.../, then the ... is interpreted as a regular expression
#   The value (if enumerated) can be the short or long form as in PropertyValueAliases.txt
##########################
# Show <unicodeSet>
#  List any set on the console, for viewing and debugging.
##########################
# Test <unicodeSet> <relation> <unicodeSet>
#
# Tests that the relation is true for the two sets. The "Test" keyword is optional.
#
#   relation := '='             // has identical contents to
#            := '⊃'             // is proper superset of
#            := '⊇'             // is superset of 
#            := '⊂'             // is proper subset of
#            := '⊆'             // is subset of
#            := '∥'             // has no intersection
#            := '≉'             // none of the above (they overlap, and neither contains the other)
#
# When this file is parsed, a parse error message may contain <@>
# to indicate the location of an error in the input line.
#
# If there is an error in the test, a comparison listing of the two sides of the relation is generated.
##########################
# In <unicodeSet> <props> (=|≠) <props>
#
# For each character in <unicodeSet>, verify that the result of applying the left <props>
# is (=|≠) the result of applying the right <props>.
#   <props> is of the form (<unicodeSet> | <prop>) ("*" (<unicodeSet> | <prop>))?
#   It is the functional composition of the properties applied to strings, whereby
#   <unicodeSet> is used to filter the result.
#   <prop> for a string property is applied to each character, and the result concatenated
#       That is, cf("A1") is cf("A")+cf("1") = "a1"
#   <prop> for an enumerated property, is applied to each character, and the result is a concatenated set.
#       That is, gc("A1") is gc("A")+gc("1") = "Uppercase_LetterDecimal_Number"
#
#   Example: for <props> of bc * \P{bc=NSM} * cf * dm, the result applied to Å (angstrom sign) are:
#       bc * \P{bc=NSM} * cf * dm ("Å")
#       bc * \P{bc=NSM} * cf ("A" + umlaut)
#       bc * \P{bc=NSM} ("a" + umlaut)
#       bc ("a")
#       "Left"
#
#   Example: In \p{dt=canonical} bc * \P{bc=NSM} * dm = bc * \P{bc=NSM}
#       This examines only those characters that have canonical compositions. For each such character X
#       it gets the decomposition mapping of X, then filters out all NSM characters, then gets the Bidi_Class.
#       It then tests that against the result of filtering out NSM characters from X, then getting the BIDI_Class.
#
##########################
# EquivalencesOf <unicodeSet> <props> (⇐|⇔|⇒|⇍|⇎|⇏) <props>
# 
# Verify that the equivalence of elements of <unicodeSet> up to the left <props> is is implied,
# equivalent, or implies equivalence up to the right <props>, or verify the negation of these
# relations.
#
# On both sides, <props> is a composition of properties and filters, as in an “In” line.
#
#   Example:
#       The case-insensitive comparison of ASCII identifiers defined by comparing their uppercase
#       mappings is equivalent to that defined by comparing their lowercase mappings:
#          EquivalencesOf \p{Block=Basic Latin} Uppercase_Mapping ⇔ Lowercase_Mapping
#       This is not true in the broader Latin script (in fact neither implication holds).
#          EquivalencesOf \p{Script=Latin} Uppercase_Mapping ⇎ Lowercase_Mapping
#       The simple and full case foldings do not define the same equivalence classes on these
#       strings:
#          Let $strings = [ {Straße} {STRASSE} {ᾠδή} {ὨΙΔΉ} {...} ]
#          EquivalencesOf $strings Case_Folding ⇎ Simple_Case_Folding
#       Specifically, full case folding is coarser than simple case folding.
#          EquivalencesOf $strings Case_Folding ⇏ Simple_Case_Folding
#          EquivalencesOf $strings Case_Folding ⇐ Simple_Case_Folding
##########################
# There is new syntax for testing UnicodeMaps
#
#  Map <unicodeMap> <relation> <unicodeMap>
#
#    unicodeMap   := { um_list }
#    umList       := umItem (addItem | removeItem | retainItem)*
#
#    umItem       := unicodeSet '=' value
#    umItem       := '\m{' '*'? propertyName '}' // the * indicates the last version, equiv to U-1: for properties.
#
#    addList      := [,|] umItem
#    removeItem   := '-' (umItem | unicodeSet) // you can remove keys (unicodeSet) from a map
#    retainItem   := '&' (umItem | unicodeSet) // you can retain keys (unicodeSet) in a map (removing others)
#
# A map is logically a set of pairs {<key1,value1​>, <key2,value2>...}, where the keys are unique
#    You can add another map to it. If any new pair has the same key as an old one, the old pair is removed.
#    You can remove a map or set from it. (Set-Difference)
#        For a set, this removes all the keys that are in the set.
#        For a map, this removes those pairs that are identical.
#    You can also retain elements from a map or set. (Intersection)
#        Sets vs Maps work similarly to removal.
#
# The relation tests the set of pairs. So two maps are equal when the pairs are the same.
#
# TODO:
#    Add value operations:
#    - remove/retain pairs with particular values
#    - extract the set of keys from a map, for pairs with particular values
#
# For debugging, you can also use:
#  ShowMap <unicodeMap>
# For example: 
#  ShowMap {\m{whitespace}-\p{whitespace=no},{[b]=strangeValue}}
#  this gets the map for whitespace, eg {' '=Yes, 'a'=No, ...}, subtracts the entries with No, and adds 'b'=strangeValue
##########################
# General Constants
##########################

Let $foo = \p{ccc=9}
Let $fii = \p{toNFD=/$foo/}

Let $codepoints = [\u0000-\U0010FFFF]

Let $gcAllPunctuation = \p{gc=/_Punctuation/}
$gcAllPunctuation = [\p{gc=Close_Punctuation}\p{gc=Connector_Punctuation}}\p{gc=Dash_Punctuation}\p{gc=Final_Punctuation}\p{gc=Initial_Punctuation}\p{gc=Open_Punctuation}\p{gc=Other_Punctuation}]

Let $gcAllSymbols = \p{gc=/_Symbol/}
$gcAllSymbols = [\p{gc=Math_Symbol}\p{gc=Currency_Symbol}\p{gc=Modifier_Symbol}\p{gc=Other_Symbol}]

Let $gcAllMarks = \p{gc=/_Mark/}
$gcAllMarks = [\p{gc=Nonspacing_Mark}\p{gc=Enclosing_Mark}\p{gc=Spacing_Mark}]

Let $gcAllLetters = \p{gc=/_Letter/}
$gcAllLetters = [\p{gc=Ll}\p{gc=Lu}\p{gc=Lo}\p{gc=Lt}\p{gc=Lm}]

##########################
# Main Stability Policies 
#   http://www.unicode.org/policies/property_value_stability_table.html
##########################

# TODO: Formal Name Alias Stability, Named Character Sequence Stability, Name Uniqueness, 
# TODO: Identity Stability, Property Stability, Alias Stability, Property Alias Uniqueness

# Encoding Stability: Once a character is encoded, it will not be moved or removed.
\p{GC=unassigned} ⊆ \p{U-1:GC=unassigned}

# Name Stability: The Unicode Name property value for any non-reserved code point will not be changed. In particular, once a character is encoded, its name will not be changed.
In \P{U-1:GC=Cn} name=U-1:name

# Formal Name Alias Stability
# TODO

# Named Character Sequence Stability
# TODO

# Name Uniqueness
# TODO

# Strong Normalization Stability (decomposition mapping, Canonical Combining Class don't change)
# In Property Section

# Identity Stability
# Can't be tested

# Property Stability: Normative and informative properties, once defined in the Unicode Character Database, will never be removed.
# TODO
    
# Alias Stability: Property aliases and property value aliases, once defined in the Unicode Character Database, will never be removed.
# TODO

# Property Alias Uniqueness: All property aliases constitute a single namespace. Property aliases are guaranteed to be unique within this namespace. For each property, all of its property value aliases constitute a separate namespace, one per property. Within each of these property value alias namespaces, property value aliases are guaranteed to be unique.
# TODO

# Identifier Stability: All strings that are valid default Unicode identifiers will continue to be valid default Unicode identifiers in all subsequent versions of Unicode. Furthermore, default identifiers never contain characters with the Pattern_Syntax or Pattern_White_Space properties.
# Covered in Property Stability Section

# Case Folding Stability: Caseless matching of Unicode strings used for identifiers is stable.
# For each string S containing only assigned characters in a given Unicode version, toCasefold(toNFKC(S)) under that version is identical to toCasefold(toNFKC(S)) under any later version of Unicode.
In \P{U-1:gc=Cn} U-1:Case_Folding * U-1:toNFKC = Case_Folding * toNFKC
# For each string S containing only characters with the property XID_Continue in a given Unicode version, toNFKC_Casefold(S) under that version is identical to toNFKC_Casefold(S) under any later version of Unicode.
# If this is violated as a result of a change to Default_Ignorable_Code_Point, the derivation of NFKC_Casefold must special-case the affected characters to restore stability.
In \p{U-1:XID_Continue} U-1:NFKC_Casefold = NFKC_Casefold
# The following is not guaranteed by the stability policy, indeed it does not hold as far back as 5.2, but we might want to know about it:
In \P{U-1:gc=Cn} U-1:NFKC_Casefold = NFKC_Casefold

# Not yet a stability policy, but see https://www.unicode.org/L2/L2023/23005.htm#174-A11.
# Simple counterparts of the above.
In \P{U-1:gc=Cn} U-1:Simple_Case_Folding * U-1:toNFKC = Simple_Case_Folding * toNFKC
In \p{U-1:XID_Continue} R-1:NFKC_Simple_Casefold = NFKC_Simple_Casefold
# As above, this one would not be guaranteed by the stability policy.
In \P{U-1:gc=Cn} R-1:NFKC_Simple_Casefold = NFKC_Simple_Casefold

# Case Pair Stability: If two characters form a case pair in a version of Unicode, they will remain a case pair in each subsequent version of Unicode. If two characters do not form a case pair in a version of Unicode, they will never become a case pair in any subsequent version of Unicode.
# TODO

# Red Flag: cased and case_ignorable should be disjoint

Let $caseOverlap = [\u02B0-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u037A\u10FC\u1D2C-\u1D61\u1D78\u1D9B-\u1DBF\u2090-\u2094\u2C7D\uA770[\u1D62-\u1D6A\u2071\u207F\u2095-\u209C\u2C7C\uA7F2-\uA7F4\uA7F8\uA7F9 \uA69C-\uA69D\uAB5C-\uAB5F\uAB69]\U00010780\U00010783-\U00010785\U00010787-\U000107B0\U000107B2-\U000107BA\U0001E030-\U0001E06D]
# 6.1.0, added 22 overlap characters
# 7.0 added \uA69C-\uA69D\uAB5C-\uAB5F
# 14.0 new modifier letters in Latin Extended-F are Lowercase (U+107xx)
# 15.0 new modifier letters in Cyrillic Extended-D are Lowercase (U+1E030..1E06C)
# 15.0 [172-A58] Action Item for Markus Scherer, PAG:
#   Give the Other_Lowercase property (and thus also Cased)
#   to modifier letter U+1E06D, for Unicode Version 15.0. See L2/22-124 item UCD3.
# 15.0 [172-A59] Action Item for Markus Scherer, PAG:
#   Give the Other_Lowercase property (and thus also Cased)
#   to the modifier letters U+10FC and U+A7F2..A7F4 and U+AB69,
#   for Unicode Version 15.0. See L2/22-124 item UCD4.
\p{cased} ∥ [\p{caseignorable} - $caseOverlap]

##########################
# Property Stability Policies
#   http://www.unicode.org/policies/stability_policy.html#Property_Value
##########################

##########################
# BIDI
##########################

# Stability: The Bidi_Class property values will not be further subdivided. 
\p{bc=/^(AL|AN|B|BN|CS|EN|ES|ET|L|LRE|LRO|NSM|ON|PDF|R|RLE|RLO|S|WS|LRI|RLI|FSI|PDI)$/} = [\u0000-\U0010FFFF]

# Stability: The property values for the bidirectional properties Bidi_Class and Bidi_Mirrored preserve canonical equivalence.
# This test utilizes the fact that bc=NSM inherit behavior in the algorithm, so these are just filtered
In \p{dt=canonical} bc * \P{bc=NSM} * dm = bc * \P{bc=NSM}

# Stability: The property values for the bidirectional properties Bidi_Class and Bidi_Mirrored preserve canonical equivalence.
# This test utilizes the fact that bc=NSM inherit behavior in the algorithm, so these are just filtered
# There are 5 special cases:
Let $BMExclusions =[≠ ∤ ∦ ≢ \u2ADC]
In [\p{dt=canonical}-$BMExclusions] Bidi_M * \P{bc=NSM} * dm = Bidi_M * \P{bc=NSM}

# Additional BIDI invariant constants
Let $AL_blocks = [\u0600-\u07BF \u0860-\u08FF \uFB50-\uFDCF \uFDF0-\uFDFF \uFE70-\uFEFF \U00010D00-\U00010D3F \U00010EC0-\U00010EFF \U00010F30-\U00010F6F \U0001EC70-\U0001ECBF \U0001ED00-\U0001ED4F \U0001EE00-\U0001EEFF]
Let $R_blocks = [\u0590-\u05FF \u07C0-\u085F \uFB1D-\uFB4F \U00010800-\U00010CFF \U00010D40-\U00010EBF \U00010F00-\U00010F2F \U00010F70-\U00010FFF \U0001E800-\U0001EC6F \U0001ECC0-\U0001ECFF \U0001ED50-\U0001EDFF \U0001EF00-\U0001EFFF]
# 6.1.0 updated blocks
# 10.0 updated blocks (Syriac Supplement is bc=AL)
# 11.0 updated blocks (Hanifi Rohingya, Sogdian, Indic Siyaq Numbers are bc=AL); Old Sogdian is bc=R
# 12.0 updated blocks (Ottoman Siyaq Numbers is bc=AL)
# 14.0 updated blocks (Arabic Extended-B is bc=AL)

# Unassigned characters in these blocks have R or AL respectively
\p{Bidi_Class=R} ⊇ [$R_blocks & \p{gc=Cn}]
\p{Bidi_Class=AL} ⊇ [$AL_blocks & \p{gc=Cn}]

# There are no strong characters of the other directionalities (out of L, AL, R) in these blocks, 
# and anything R or L is in the block (or RLM)
$R_blocks ∥ [\p{Bidi_Class=L} \p{Bidi_Class=AL}]
$AL_blocks ∥ [\p{Bidi_Class=L} \p{Bidi_Class=R}]
[$R_blocks $AL_blocks \N{RIGHT-TO-LEFT MARK}] ⊇ [\p{Bidi_Class=AL} \p{Bidi_Class=R}] #200f


# U6.0: BN characters are default ignorable, noncharacters, controls, minus marks, bidi-controls, alphabetic, whitespace, with a few exceptions

Let $BN_Exceptions = [\u001C-\u001F\u17B4\u17B5]

[\p{Bidi_Class=BN}] = [\p{di}\p{nchar}\p{gc=Cc}-\p{gc=Mc}-\p{gc=Mn}-\p{gc=Me}-\p{Bidi_C}-\p{alpha}-\p{wspace} - $BN_Exceptions]

# Nonspacing and enclosing combining marks are bc=NSM, with a few exceptions (all of which are nonspacing)
Let $gcMn_bcL = [\u0CBF\u0CC6\U00011A07\U00011A08\U00011C3F]
\p{bc=NSM} = [\p{gc=Mn} \p{gc=Me} - $gcMn_bcL]

##########################
# Case
##########################

# Stability: The Case_Folding property value is limited so that no string when case folded expands to more than 3× in length (measured in code units). 
\p{cf=/..../} = []
# Note: This bound is tight:
\p{cf=/.../} ⊃ []

# Case folding is not the same as lowercasing: Cherokee case folds to uppercase.
In \p{sc=Cher} cf = uc
In \p{sc=Cher} scf = suc

# Simple and full case foldings define the same equivalence classes on code points.
# This used not to be true, but was rectified by
# https://www.unicode.org/cgi-bin/GetL2Ref.pl?175-C19.
EquivalencesOf $codepoints Case_Folding ⇔ Simple_Case_Folding

# Stability: All characters with the Lowercase property and all characters with the Uppercase property have the Alphabetic property. 
\p{Alphabetic} ⊃ [\p{Uppercase} \p{Lowercase}]

##########################
# General
##########################

# Stability: The General_Category property values will not be further subdivided. 
\p{gc=/^(Cc|Cf|Cn|Co|Cs|Ll|Lm|Lo|Lt|Lu|Mc|Me|Mn|Nd|Nl|No|Pc|Pd|Pe|Pf|Pi|Po|Ps|Sc|Sk|Sm|So|Zl|Zp|Zs)$/} = [\u0000-\U0010FFFF]

# Stability: The General_Category property value Control (Cc) is immutable: the set of code points with that value will never change. 
\p{GC=Cc} = \p{U-1:GC=Cc}

# Stability: The General_Category property value Private_Use (Co) is immutable: the set of code points with that value will never change. 
\p{GC=Co} = \p{U-1:GC=Co}

# Stability: The General_Category property value Surrogate (Cs) is immutable: the set of code points with that value will never change.  
\p{GC=Cs} = \p{U-1:GC=Cs}

# Stability: The set of characters having General_Category=Nd will always be the same as the set of characters having Numeric_Type=de.
\p{General_Category=Decimal_Number} = \p{Numeric_Type=Decimal}

# Stability: Once a character is assigned, both its Name and its Jamo_Short_Name will never change. 
# Name is covered in Main policies
# TODO: Short Name

# Stability: The Noncharacter_Code_Point property is an immutable code point property, which means that its property values for all Unicode code points will never change.
\p{NChar} = \p{U-1:NChar}

##########################
# Identifier Stability
##########################

# Stability: Once a character is ID_Continue, it must continue to be so in all future versions. 
\p{ID_Continue} ⊇ \p{U-1:ID_Continue}

# Stability: If a character is ID_Start then it must also be ID_Continue. 
\p{ID_Continue} ⊇ \p{ID_Start}

# Stability: Once a character is ID_Start, it must continue to be so in all future versions. 
\p{ID_Start} ⊇ \p{U-1:ID_Start}

# Stability: Once a character is XID_Continue, it must continue to be so in all future versions. 
\p{XID_Continue} ⊇ \p{U-1:XID_Continue}

# Stability: If a character is XID_Start then it must also be XID_Continue. 
\p{XID_Continue} ⊇ \p{XID_Start}

# Stability: If a character is XID_Start then it must also be XID_Continue. 
\p{XID_Start} ⊇ \p{U-1:XID_Start}

# While the above stability policy is only applicable back to 4.1.0+ for the
# Continue properties, recent versions of Unicode are compatible further back.
# See https://www.unicode.org/cgi-bin/GetL2Ref.pl?176-C18.
\p{XID_Start} ⊇ \p{U3.1.0:XID_Start}
\p{ID_Start} ⊇ \p{U3.1.0:ID_Start}
\p{XID_Continue} ⊇ \p{U3.1.0:XID_Continue}
\p{ID_Continue} ⊇ \p{U3.1.0:ID_Continue}

# Stability: The Pattern_Syntax and Pattern_Whitespace properties are immutable code point properties, which means that their property values for all Unicode code points will never change.
\p{Pattern_Whitespace} = \p{U-1:Pattern_Whitespace}
\p{Pattern_Syntax} = \p{U-1:Pattern_Syntax}

# Stability: If a character has the Pattern_Syntax or Pattern_White_Space property, then it cannot have the ID_Continue or XID_Continue property.
# (Also tests that Pattern_Syntax is disjoint from Pattern_White_Space)

\p{ID_Continue} ∥ [\p{Pattern_Whitespace} \p{Pattern_Syntax}]
\p{Pattern_Whitespace} ∥ [\p{ID_Continue} \p{Pattern_Syntax}]
\p{Pattern_Syntax} ∥ [\p{ID_Continue} \p{Pattern_Whitespace}]

\p{XID_Continue} ∥ [\p{Pattern_Whitespace} \p{Pattern_Syntax}]
\p{Pattern_Whitespace} ∥ [\p{XID_Continue} \p{Pattern_Syntax}]
\p{Pattern_Syntax} ∥ [\p{XID_Continue} \p{Pattern_Whitespace}]

# The X versions are subsets of the the plain versions
# Should add as stability provision
\p{ID_Continue} ⊇ \p{XID_Continue}
\p{ID_Start} ⊇ \p{XID_Start}

# Not a stability policy, but we probably should avoid breaking it further:
# The sets \p{ID_Start} and and \p{ID_Continue} preserve backward compatibility
# with the General_Category-based identifier definition from Unicode 3.0, except
# for \p{Cf}, which was ignored in identifier comparison, and for one—thankfully
# obscure—letter added to \p{Pattern_Syntax} in Unicode 5.1.
# See https://www.unicode.org/versions/Unicode3.0.0/ch05.pdf#page=31.
#
# NOTE: If this invariant needs to change, the section on migrating from the
#       Unicode 3.0 identifier definition in UTS #55 must be updated:
#       https://www.unicode.org/reports/tr55/#Evolution-Unicode-3.
Let $identifier_start = [\p{GC=Lu}\p{GC=Ll}\p{GC=Lt}\p{GC=Lm}\p{GC=Lo}\p{GC=Nl}]
Let $identifier_extend = [\p{GC=Mn}\p{GC=Mc}\p{GC=Nd}\p{GC=Pc}]
[\p{ID_Start}\p{Name=VERTICAL TILDE}]    ⊇ $identifier_start
[\p{ID_Continue}\p{Name=VERTICAL TILDE}] ⊇ [$identifier_start $identifier_extend]

[\p{XID_Start}\p{Name=VERTICAL TILDE}]    ⊇ [$identifier_start-\p{NFKC_QC=No}]
[\p{XID_Continue}\p{Name=VERTICAL TILDE}] ⊇ [[$identifier_start $identifier_extend]-\p{NFKC_QC=No}]

##########################
# Normalization
##########################

# Stability: The Canonical_Combining_Class property values are limited to the values 0 to 255. 
\p{CCC=/^([0-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/} = [\u0000-\U0010FFFF]

# Stability: Once a character is assigned, its Canonical_Combining_Class will never change. 
In \P{U-1:GC=Cn} ccc=U-1:ccc

# Canonical decompositions (minus exclusions) must be identical across releases (also required by strong normalization stability),
# except where a character and at least one character in its decomposition are both new in the release.
Let $New_Decompositions = [[\p{Decomposition_Type=Canonical} - \p{Full_Composition_Exclusion}] - [\p{U-1:Decomposition_Type=Canonical} - \p{U-1:Full_Composition_Exclusion}]]
$New_Decompositions ⊆ \p{U-1:GC=Cn}
# Stripping previously-unassigned characters from the current NFD does
# something, that is, the decomposition contains newly-assigned characters.
In $New_Decompositions toNFD * \P{U-1:GC=Cn} ≠ toNFD

Let $Unicode_13_Decompositions = [[\p{U13.0.0:Decomposition_Type=Canonical} - \p{U13.0.0:Full_Composition_Exclusion}] - [\p{U12.1.0:Decomposition_Type=Canonical} - \p{U12.1.0:Full_Composition_Exclusion}]]
$Unicode_13_Decompositions ⊆ \p{U12.1.0:GC=Cn}
In $Unicode_13_Decompositions toNFD * \P{U12.1.0:GC=Cn} ≠ toNFD
$Unicode_13_Decompositions = [\U00011938]
$Unicode_13_Decompositions = [\p{Name=DIVES AKURU VOWEL SIGN O}]

Let $Unicode_7_Decompositions = [[\p{U7.0.0:Decomposition_Type=Canonical} - \p{U7.0.0:Full_Composition_Exclusion}] - [\p{U6.3.0:Decomposition_Type=Canonical} - \p{U6.3.0:Full_Composition_Exclusion}]]
$Unicode_7_Decompositions ⊆ \p{U6.3.0:GC=Cn}
In $Unicode_7_Decompositions toNFD * \P{U6.3.0:GC=Cn} ≠ toNFD
$Unicode_7_Decompositions = [\U0001134B-\U0001134C \U000114BB-\U000114BC \U000114BE \U000115BA-\U000115BB]
$Unicode_7_Decompositions ⊆ [\p{Name=/^(GRANTHA|TIRHUTA|SIDDHAM) VOWEL SIGN /}]

Let $Unicode_6_1_Decompositions = [[\p{U6.1.0:Decomposition_Type=Canonical} - \p{U6.1.0:Full_Composition_Exclusion}] - [\p{U6.0.0:Decomposition_Type=Canonical} - \p{U6.0.0:Full_Composition_Exclusion}]]
$Unicode_6_1_Decompositions ⊆ \p{U6.0.0:GC=Cn}
In $Unicode_6_1_Decompositions toNFD * \P{U6.0.0:GC=Cn} ≠ toNFD
$Unicode_6_1_Decompositions = [\U0001112E-\U0001112F]
$Unicode_6_1_Decompositions ⊆ [\p{Name=/^CHAKMA VOWEL SIGN /}]

# Stability: All characters other than those with General_Category property values Spacing_Mark (Mc) and Nonspacing_Mark (Mn) have the Canonical_Combining_Class property value 0.
\p{CCC=0} ⊇ [^ \p{GC=Mc} \p{GC=Mn}]

# Stability: Canonical and compatibility mappings (Decomposition_Mapping property values) are always in canonical order, and the resulting recursive decomposition will also be in canonical order. 
# Note: We really mean the fixed point of Decomposition_Mapping on the left-hand side here.
In \P{Decomposition_Mapping=} Decomposition_Mapping * Decomposition_Mapping * Decomposition_Mapping = toNFKD

# Stability: Canonical mappings (Decomposition_Mapping property values) are always limited either to a single value or to a pair. The second character in the pair cannot itself have a canonical mapping. 
[ \p{Decomposition_Type=Canonical} & \p{Decomposition_Mapping=/.../} ] = []
# TODO: The second character in the pair cannot itself have a canonical mapping.

# Stability: Canonical mappings (Decomposition_Mapping property values) are always limited so that no string when normalized to NFC expands to more than 3× in length (measured in code units). 
\p{toNFC=/..../} = []
# Note: This bound is tight:
\p{toNFC=/.../} ⊃ []

# Stability: Once a character is assigned, its Decomposition_Mapping will never change. 
In \P{U-1:GC=Cn} dm=U-1:dm

# U6.0: Construction of Full_Composition_Exclusion
# Primary Composites don't include singletons, ccc!=0, or sequences starting with ccc!=0
Let $combiningExclusions = [\p{dt=canonical}-\P{nfcqc=N}-\P{nfdqc=N}]

Let $singletons = \p{toNFD=/^.$/}
Let $nonstarter = \P{ccc=0}
Let $firstNonStarter = \p{toNFD=/^$nonstarter/}

$combiningExclusions ⊇ [$singletons & \p{dt=canonical}]
$combiningExclusions ⊇ [$nonstarter & \p{dt=canonical}]
$combiningExclusions ⊇ [$firstNonStarter & \p{dt=canonical}]

##########################
# Other Invariant Tests, not in Stability Policies
##########################

# 138-A029 check that STerm is a proper subset of Terminal_Punctuation

\p{Terminal_Punctuation} ⊃ \p{STerm}

# 132-M3 if a character has a general category of "Number", it must have a numeric type that is not equal to "none".

[\p{General_Category=Decimal_Number}\p{General_Category=Letter_Number}\p{General_Category=Other_Number}] ∥ \p{Numeric_Type=None}

# 133-C25] The distinction between numeric type = digit and and numeric type = numeric is not useful. 
# No new characters will be assigned the numeric type "digit"

\p{Numeric_Type=Digit} = \p{U-1:Numeric_Type=Digit}

##########################
# Numbers
##########################

# Decimals are 0-9

Let $decimalValue = [\p{Numeric_Value=/^[0-9]+(.0)?$/}]

$decimalValue ⊇ \p{General_Category=Decimal_Number}

# All and only those items with numeric types have numeric values

Let $anyNumericValue = \p{Numeric_Value=/-?[0-9]+(.[0-9]+)?/}
[\p{Numeric_Type=Decimal} \p{Numeric_Type=Digit} \p{Numeric_Type=Numeric}] = $anyNumericValue

##########################
# Misc Properties
##########################

# Musical symbol combining marks, other oddities

Let $AlphaExclusions = [\uAA7D \u0F3E\u0F3F\u1063\u1064\u1069-\u106D\u1087-\u108C\u108F\u109A\u109B\u1CE1\u1CF7\uAA7B\uABEC\U0001D165\U0001D166\U0001D16D-\U0001D172][[:gc=mc:]&[:ccc=9:][\u302E\u302F]]
# 6.1.0 Added HANGUL SINGLE DOT TONE MARK..HANGUL DOUBLE DOT TONE MARK
# 7.0 Added AA7D
# 10.0 Added 1CF7 (similar to 1CE1)
\p{Alphabetic} ⊇ [\p{GC=Lu} \p{GC=Ll} \p{GC=Lt} \p{GC=Lm} \p{GC=Lo} \p{GC=Nl} \p{GC=Mc} - $AlphaExclusions]

# Show [\p{GC=Mc} - \p{alphabetic}]
# Show [\p{GC=Mc} & \p{alphabetic}]


\p{Whitespace} ⊃ [\p{GC=Zs} \p{GC=Zp} \p{GC=Zl}]
\p{GC=Zs} ≉ \p{Name=/SPACE/}

\p{Dash} ⊃ [\p{GC=Pd}]

\p{Script=Common} ∥ [\p{GC=Mn} \p{GC=Me} \p{Join_Control}]
\p{Script=Inherited} ⊆ [\p{GC=Mn} \p{GC=Me} \p{Join_Control}]
\p{Script=Unknown} = [\p{GC=Cn} \p{GC=Co} \p{GC=Cs}]

Show [\u20b9]

# [\p{Alphabetic}] ∥ \p{Script=Common}
#  & [\p{Decomposition_Type=None} \p{Decomposition_Type=Canonical}]

# The UTC 172 script ad hoc report (L2/22-128) item VII 27 “Nonalphabetic bindus” points out that
# “Most characters with InSC=Bindu have Alphabetic=Yes”
# and adjustments have been made so that all current bindus have Alphabetic=Yes.
# The check below enforces that rule, but allows for possible future
# exceptions. Should such exceptions arise, they can be added to the definition of
# $nonAlphabeticBindus to avoid a failure on this test.
Let $nonAlphabeticBindus = []
[\p{InSc=Bindu} - \p{Alphabetic}] = $nonAlphabeticBindus

Let $nonAlphabeticDependentVowels = [\N{ORIYA SIGN OVERLINE}\N{THAI CHARACTER MAITAIKHU}\N{LIMBU SIGN KEMPHRENG}\N{SHARADA VOWEL MODIFIER MARK}\N{SHARADA EXTRA SHORT VOWEL MARK}]
[\p{InSC=Vowel_Dependent} - \p{Alphabetic}] = $nonAlphabeticDependentVowels

# Combining letters are often alphabetic (medievalist abbreviations).
# The others are diacritic (cantillation marks, phonetics).
# See 177-CXX.
\p{name=/COMBINING .* LETTER/} ⊆ [\p{Alphabetic}\p{Diacritic}]

# Nuktas should probably be diacritic, but as of 15.1 this is only the case of
# those that have NUKTA in their name.
# See https://github.com/unicode-org/properties/issues/195#issuecomment-1804962555.
Let $nonDiacriticNuktas = [\u1BE6\U00010A38\U00010A39\U00010A3A\U0001133B]
[\p{InSc=Nukta} - \p{Diacritic}] = $nonDiacriticNuktas

##########################
# LineBreak property
##########################

Let $IDInclusions = [[:block=/Ideographs/:] [[\U00020000-\U0003FFFF][\U0001F000-\U0001FFFF] - [[:block=Symbols for Legacy Computing:][:block=Supplemental Arrows C:]]] & [:gc=Cn:] - [:NChar:]]
# 9.0 Added range 1F000..1FFFF: all undesignated code points in this range are lb=ID
# 13.0 exclude those in 1FB00..1FBFF Symbols for Legacy Computing
# 16.0 exclude Supplemental Arrows C
\p{LB=ID} ⊃ $IDInclusions
\p{Line_Break=Unknown} = [\p{General_Category=Unassigned} \p{GeneralCategory=PrivateUse} - $IDInclusions - [\u20C0-\u20CF]]

Let $BrahmicLineBreaking = [\p{sc=Balinese}\p{sc=Batak}\p{sc=Brahmi}\p{sc=Cham}\p{sc=DivesAkuru}\p{sc=Grantha}\p{sc=Javanese}\p{sc=Makasar}\p{sc=Kawi}\p{sc=Cham}\p{sc=Makasar}\p{sc=Tulu_Tigalari}\p{sc=Gurung_Khema}]
Let $VFScripts = [\p{sc=Batak}]

Let $OPInclusions = [\u00A1\u00BF\u2E18\U00013258-\U0001325A\U00013286\U00013288\U00013379\U0001342F\U00013437\U0001343C\U0001343E\U000145CE\U0001E95E-\U0001E95F]
# 7.0 Removed hack  - [\u2308\u230A]
# 9.0 Added Adlam initial punctuation 1E95E..1E95F
# 12.0 Added Egyptian control begin segment 13437 (gc=Cf, lb=OP)
# 15.0 Added Egyptian control begin enclosure 1343C, begin walled enclosure 1343E (gc=Cf, lb=OP)
# 15.1 UTC AI 173-A9: Change the Line_Break value of U+1342F EGYPTIAN HIEROGLYPH V011D from AL to OP.

\p{LB=OP} = [\p{GC=Ps} $OPInclusions]
[\p{LB=CL}\p{LB=CP}] ⊃ [\p{GC=Pe} - [\u2309\u230B]]

# See L2/22-086 for an explanation of the special case of Batak.
# (Note that Consensus 177-C43 changed the Batak viramas from InSC=Pure_Killer to Reordering_Killer.)
\p{LB=VI} = [[\p{Indic_Syllabic_Category=Virama}\p{Indic_Syllabic_Category=Invisible_Stacker}] & $BrahmicLineBreaking]
\p{LB=VF} = [\p{Indic_Syllabic_Category=Reordering_Killer} & $VFScripts]

# 15.1: Action item UTC-176-A81: change [[:PCM:]-\u070F] lb=AL->NU
\p{LB=CM} = [[\u3035] \p{GC=Mn} \p{GC=Me} \p{GC=Mc} \p{GC=Cc} \p{GC=Cf} -[\U00013437\U00013438\U0001343C-\U0001343F] -\p{LB=SA} -\p{LB=WJ} -\p{LB=ZW} -\p{LB=BA} -\p{LB=LF} -\p{LB=BK} -\p{LB=CR} -\p{LB=NL} -\p{LB=GL} -\p{LB=AL} -\p{LB=ZWJ} - \p{LB=VI} - \p{LB=VF} - \p{LB=NU}]
# Excluded Egyptian controls begin/end segment etc. 13437, 13438 & 1343C..1343F (gc=Cf, lb=OP/CL)

#  3.0.0: Numeric characters consist of decimal digits (all characters of General_Category Nd),
#         except those with East_Asian_Width F (Fullwidth)
# 15.1.0: and those from scripts that use the Brahmic style of context analysis,
#  4.0.1: plus these characters: 066B ARABIC DECIMAL SEPARATOR, 066C ARABIC THOUSANDS SEPARATOR.
# 15.1.0: Action item UTC-176-A81: change [[:PCM:]-\u070F] lb=AL->NU
Let $NUInclusions = [\u066B\u066C]
Let $NUFormats = [[:PCM:]-[\u070F]]
\p{LB=NU} = [\p{GC=Nd} $NUInclusions $NUFormats - \p{EA=F} - $BrahmicLineBreaking]

# Digits are lb=AS in scripts with brahmic line breaking.
[\p{GC=Nd} & $BrahmicLineBreaking] ⊆ \p{LB=AS}

# Batak is the one case where assigning LB=AS to digits could lead to unexpected results, because
# of the rule (AK | ◌ | AS) × (AK | ◌ | AS) VF.  There are no Batak digits.
[\p{GC=Nd} & $VFScripts] = []

Let $PRInclusions = [\u002b\u005c\u00b1\u2116\u2212\u2213\u20C0-\u20CF]
\p{LB=PR} = [\p{GC=Sc} $PRInclusions - \p{LB=PO}]

Let $QUInclusions = [\u275F-\u2760 \U0001F676-\U0001F678 \u0022 \u0027 \u275B-\u275E \u2E00-\u2E01 \u2E06-\u2E08 \u2E0B]
# 7.0 added 275F..2760 1F676..1F678
\p{LB=QU} = [\p{GC=Pf} \p{GC=Pi} $QUInclusions]
\p{LB=SG} = \p{GC=Cs}
\p{LB=SP} = \N{SPACE}
\p{LB=SY} = \N{SOLIDUS}

# The classes WJ and ZW are reserved for characters meant as explicit overrides
# to the line breaking algorithms.  For historical reasons, WJ has two such
# characters, see L2/00-258.
# These invariants should not change unless a change to the overrides is being
# considered.  In particular, ordinary characters whose joining or shaping
# behaviour requires the prohibition of line breaks on either side should have
# class GL.
\p{LB=WJ} = [\N{WORD JOINER} \N{ZERO WIDTH NO-BREAK SPACE}]
\p{LB=ZW} = \N{ZERO WIDTH SPACE}

\p{LB=ZWJ} = [\u200D]
\p{LB=RI} = \p{RI=Y}


# A few southeast Asian scripts allow line breaks only at word boundaries,
# but do not mark word boundaries in any way, so that the
# determination of line break opportunities requires language dependent text analysis.
# In terms of UAX #14, these scripts need the “South East Asian” style of context analysis for
# line breaking, and their characters are given lb=SA (Line_Break=SA: complex context dependent)
# as an escape out of the rule-based algorithm in UAX #14.
#
# For these scripts, test the following invariant:
# 
# Add all characters that have an explicit Script property value from among the
# set of scripts known to use Line_Break=SA values to the set $SAScripts. Then
# the intersection of the $SAScripts set with the set of characters whose Line_Break
# values are either LineBreak=SA or LineBreak=CM should always be
# identical to the intersection of the $SAScripts set with the set of characters
# which are Alphabetic=True or whose General_Category values are General_Category=Cf
# or General_Category=Mn. 
# 
# Exceptional cases for which characters in $SAScripts have LineBreak=SA but
# where those characters are non-alphabetic or have General_Category other
# than Cf or Mn (such as General_Category=No numerical characters) are
# covered by adding them to the exception set $SAScriptExceptions for the test.

# SA are limited to certain scripts:
Let $SAScripts = [\p{script=ahom} \p{script=thai} \p{script=lao} \p{script=myanmar} \p{script=khmer} \p{script=Tai_Le} \p{script=New_Tai_Lue} \p{script=Tai_Tham} \p{script=Tai_Viet}]
$SAScripts ⊇ \p{LineBreak=SA}

# And in $SA scripts, they are all the alphabetic spacing characters, plus some odd Cf & Mn, plus the NEW TAI LUE THAM DIGIT ONE
Let $SAScriptExceptions = [\x{1173A}\x{1173B}\x{1173F} \u19DA\u109E\u109F\u19DE\u19DF\u1AA0-\u1AA6\u1AA8-\u1AAD\uAA77-\uAA79\uAADE-\uAADF]
# 7.0 Added AA7D
# 12.0 Removed Myanmar spacing marks which were assigned Other_Alphabetic: 1063..1064, 1069..106D, 1087..108C, 108F, 109A..109B, AA7B, AA7D

[$SAScripts & [\p{Alphabetic} \p{gc=cf} \p{gc=Mn} $SAScriptExceptions]] = [$SAScripts & [\p{LineBreak=SA} \p{LineBreak=CM}]]

# Make sure there are not redundancies in the $SAScriptExceptions. These are not formally a problem, but make the test cleaner

$SAScriptExceptions ∥ [\p{Alphabetic} \p{gc=cf} \p{gc=Mn}]

##########################
# Word Break
##########################

# 6.0: Compare word characters with similar identifier characters

# UAX 31 Table 3: Candidate Characters for Inclusion in Identifiers
# Warning: the uax31 tables don't have machine-readable tables, so must be updated each release.
Let $uax31table3 = [\u0027\u002D\u002E\u003A\u00B7\u058A\u05F3\u05F4\u0F0B\u200C\u200D\u2010\u2019\u2027\u30A0\u30FB]

Let $WBRemovals = [\u0387\u0604\u2018\u2024\u202F\u2E2F\uFE13\uFE52\uFE55\uFF07\uFF0E\uFF1A\u200c\u200d'.\:\u00AD\u00B7\u05F3\u05F4\u0600-\u0603\u06DD\u070F\u17B4\u17B5\u200E\u200F\u2019\u2027\u202A-\u202E\u2060-\u2064\u206A-\u206F\uFEFF\uFFF9-\uFFFB\u02C2-\u02C5\u02D2-\u02D6\u02DE-\u02DF\u02ED\u02EF-\u02FF\uA720-\uA721\uA789-\uA78A\uAB5B\u055B\u055C\u055E\U000110BD\U0001D173-\U0001D17A\U000E0001\U000E0020-\U000E007F\p{gc=Cf}\p{Block=Enclosed Alphanumerics}[\u02D7\u0605\u061C\u180E\u2066-\u2069\U0001BCA0-\U0001BCA3\U0001F130-\U0001F149\U0001F150-\U0001F169\U0001F170-\U0001F189\U0001F3FB-\U0001F3FF]]
Let $WBRemovals13 = [\u02E5-\u02EB\u055A\u058A\uA708-\uA716\u055F]
# 9.0 corrected \p{gc=Cf} and added 202F
# 10.0 added 34 characters which were absorbed into WB=LE (see http://www.unicode.org/reports/tr29/tr29-30d2.html#ALetter)
# 11.0 added 5 skin tone modifiers which were absorbed into WB=Extend
# 11.0 added 3 Armenian punctuation marks which were absorbed into WB=LE (see http://www.unicode.org/L2/L2018/18115.htm#155-C3)
# 13.0 added 24 characters (mostly tone modifiers) which were absorbed into WB=LE (see http://www.unicode.org/reports/tr29/tr29-36.html#ALetter)
# 13.0 added 055F which was absorbed into WB=ML (see http://www.unicode.org/reports/tr29/tr29-36.html#MidLetter)

Let $Uax31Removals = [\-\u058A\u0F0B\u2010\u30A0\u30FB\u2E2F\u17B4-\u17B5]
# 6.1.0 adjust SAMVAT, KHMER VOWEL INHERENT*

[\p{Alpha}\p{WB=Extend}\p{WB=FO}\p{WB=LE}\p{WB=ML}\p{WB=MB}\p{WB=EX}-$WBRemovals-$WBRemovals13] = [$gcAllLetters $gcAllMarks \p{gc=Nl}\p{gc=Pc}-$Uax31Removals]

# Don’t break words after GCB=Prepend characters (that would be within a
# grapheme cluster).
# GCB=Prepend should not be WB=Format, PRI469 [Fri Jan 6 18:26:42 CST 2023].
# We prevent that by excluding GCB=Prepend from Format.
# We need to make sure that we remember to put them somewhere else appropriate
# for their usage, so we check that they are not left in WB=Other.
[\p{GCB=Prepend}&\p{WB=Format}] = []
[\p{GCB=Prepend}&\p{WB=Other}] = []

##########################
# Derivations
##########################

\p{Math} = [\p{Other_Math} \p{GC=Sm}]
\p{Alphabetic} = [\p{Other_Alphabetic} \p{GC=Lu} \p{GC=Ll} \p{GC=Lt} \p{GC=Lm} \p{GC=Lo} \p{GC=Nl}]
\p{Lowercase} = [\p{Other_Lowercase} \p{GC=Ll}]
\p{Uppercase} = [\p{Other_Uppercase} \p{GC=Lu}]
\p{ID_Start} = [\p{Other_ID_Start} \p{GC=Lu} \p{GC=Ll} \p{GC=Lt} \p{GC=Lm} \p{GC=Lo} \p{GC=Nl} - \p{Pattern_Syntax} - \p{Pattern_White_Space}]
\p{ID_Continue} = [\p{Other_ID_Continue} \p{ID_Start} \p{GC=Mn} \p{GC=Mc} \p{GC=Nd} \p{GC=Pc} - \p{Pattern_Syntax} - \p{Pattern_White_Space}] 

# See derivation of Default_Ignorable_Code_Point in DerivedCoreProperties.txt
Let $Annotations = [\uFFF9-\uFFFB]
Let $EgyptianControls = [\U00013430-\U00013440]
\p{Default_Ignorable_Code_Point} = [\p{Other_Default_Ignorable_Code_Point} \p{GC=Cf} \p{Variation_Selector} - [\p{White_Space} $Annotations $EgyptianControls \p{PCM}]]

\p{Grapheme_Extend} = [\p{Other_Grapheme_Extend} \p{GC=Me} \p{GC=Mn}]

\p{Grapheme_Base} = [^\p{GC=Cc} \p{GC=Cf} \p{GC=Cs} \p{GC=Co} \p{GC=Cn} \p{GC=Zl} \p{GC=Zp} \p{Grapheme_Extend}]
\p{Grapheme_Link} = \p{CCC=Virama}

# "Minimal" Other_: NOT hard requirements; just if we want to be minimal
# (Should add way to make these warnings, not errors)

\p{Other_Math} = [\p{Math} - \p{GC=Sm}]
\p{Other_Alphabetic} = [\p{Alphabetic} - [\p{GC=Lu} \p{GC=Ll} \p{GC=Lt} \p{GC=Lm} \p{GC=Lo} \p{GC=Nl}]]
\p{Other_Lowercase} = [\p{Lowercase} - \p{GC=Ll}]
\p{Other_Uppercase} = [\p{Uppercase} - \p{GC=Lu}]
\p{Other_ID_Start} = [\p{ID_Start} - [\p{GC=Lu} \p{GC=Ll} \p{GC=Lt} \p{GC=Lm} \p{GC=Lo} \p{GC=Nl} - \p{Pattern_Syntax} - \p{Pattern_White_Space}]]
\p{Other_ID_Continue} = [\p{ID_Continue} - [\p{ID_Start} \p{GC=Mn} \p{GC=Mc} \p{GC=Nd} \p{GC=Pc} - \p{Pattern_Syntax} - \p{Pattern_White_Space}]]

\p{Other_Default_Ignorable_Code_Point} = [\p{Default_Ignorable_Code_Point} - [\p{GC=Cf} \p{Variation_Selector} - [\p{White_Space} $Annotations]]]
\p{Other_Grapheme_Extend} = [\p{Grapheme_Extend} - [\p{GC=Me} \p{GC=Mn}]]

\p{GCB=Prepend} = [\p{InSC=Consonant_Preceding_Repha} \p{InSC=Consonant_Prefixed} \p{PCM}]
\p{GCB=Extend} = [\p{Grapheme_Extend} \p{Emoji_Modifier}]
# 11.0: GCB=Extend is no longer identical to Grapheme_Extend=Y
\p{WB=Extend} = [\p{Grapheme_Extend} \p{GC=Mc} [\U0001F3FB-\U0001F3FF] - [\u200D]]
# 11.0: skin tone modifiers were absorbed into WB=Extend
\p{SB=Extend} = [\p{Grapheme_Extend} \p{GC=Mc} \u200D]

\p{RI=Y} = [\p{GCB=RI}]
\p{RI=Y} = [\p{WB=RI}]

# Post-base spacing combining marks (gc=Mc, InPC=Right) of certain SE Asian scripts
# are explicitly excluded from GCB=SpacingMark, and instead should fall through to GCB=XX.
# This allows to position cursors inside clusters.
# See https://www.unicode.org/reports/tr29/#SpacingMark
# When this test case fails, then
# either adjust the set of scripts, or
# - change ToolUnicodePropertySource.java to remove the offending characters from the gcbSpacingMarkSet
# - add them to the exceptions list in UAX #29
Let $PostBaseSpacingMarks_All = [[:sc=Myanmar:][:sc=Tai_Tham:][:sc=Ahom:] & [:gc=Mc:] & [:InPC=Right:]]
Let $PostBaseSpacingMarks_Tweak = [\u103B \u1056 \u1057 \u1A57 \u1A6D]
Let $PostBaseSpacingMarks_Missed = []
[$PostBaseSpacingMarks_All - $PostBaseSpacingMarks_Tweak - $PostBaseSpacingMarks_Missed] ⊂ [:GCB=XX:]

# Check the consistency of grapheme cluster segmentation (both legacy and
# extended) with canonical equivalence.
# Non-starters are GCB=Extend or GCB=SpacingMark, so that GB9 and GB9a keep
# together any sequences that may be reordered by the Canonical Ordering
# Algorithm.  This has been true ever since Extended Grapheme Clusters were
# added.
\P{U5.1.0:ccc=0} ⊆ [\p{U5.1.0:GCB=Extend}\p{U5.1.0:GCB=SpacingMark}]
\P{ccc=0} ⊆ [\p{GCB=Extend}\p{GCB=SpacingMark}]
# Non-starters are actually GCB=Extend, so that GB9 alone does the job, since
# there is no GB9a in legacy grapheme clusters.
# But not before Unicode Version 16.0, even though we were saying so since
# Unicode Version 4.0 (https://www.unicode.org/reports/tr29/tr29-4.html#Implementation_Notes),
# oops (see L2/24-009).
\P{U4.0.0:ccc=0} ⊆ \p{U4.0.0:Grapheme_Extend}
\P{U4.1.0:ccc=0} ⊆ \p{U4.1.0:GCB=Extend}
\P{U15.1.0:ccc=0} ⊆ \p{U15.1.0:GCB=Extend}
\P{ccc=0} ⊆ \p{GCB=Extend}

# Characters that appear in non-initial position in the canonical decomposition
# of another character are either Extend, V, or T, so that sequences that are
# equivalent to a canonical composite are kept together by GB6..GB9.
# We only look at the starters, since we dealt with non-starters above.
# Characters that appear in non-initial position in the canonical decomposition
# of a primary composite are NFC_QC=Maybe.  We would need to separately check
# the characters that appear in non-initial position in the canonical
# decomposition of a full composition exclusion.
# We would also need to separately check that the characters are T or V only
# appear in canonical decompositions where they follow an LV, LVT, V, or T, or
# an LV or V, respectively.
[\p{NFC_QC=Maybe}&\p{ccc=0}] ⊆ [\p{GCB=Extend}\p{GCB=T}\p{GCB=V}]

##########################
# Emoji
##########################

\p{RI} ⊂ \p{Emoji_Component}
\p{Emoji_Modifier} ⊂ \p{Emoji_Component}
\p{Emoji_Component} ≉ \p{Emoji}
\p{Emoji_Modifier_Base} ⊂ \p{Emoji}
\p{Emoji_Modifier} ⊂ \p{Emoji_Presentation}
\p{Emoji_Presentation} ⊂ \p{Emoji}

Let $HairComponents = [\U0001F9B0-\U0001F9B3]
[\p{Extended_Pictographic} & \p{Emoji_Component}] = $HairComponents
\p{Extended_Pictographic} ⊃ [\p{Emoji} - \p{Emoji_Component}]
\p{Extended_Pictographic} ⊃ [\p{Emoji_Presentation} - \p{Emoji_Component}]

# lb=EB:
# https://www.unicode.org/reports/tr14/#EB
# "This class directly corresponds to the Emoji_Modifier_Base property"
\p{lb=EB} = \p{Emoji_Modifier_Base}

# lb=EM:
# https://www.unicode.org/reports/tr14/#EM
# "This class directly corresponds to the Emoji_Modifier property"
\p{lb=EM} = \p{Emoji_Modifier}

# Recent pictographs with default emoji presentation are lb=ID, EB or EM:
[\p{Emoji_Presentation} & [\p{age=7.0}\p{age=8.0}\p{age=9.0}\p{age=10.0}\p{age=11.0}\p{age=12.0}\p{age=13.0}\p{age=14.0}\p{age=15.0}]] ⊂ [\p{lb=ID} \p{lb=EB} \p{lb=EM}]

[\p{Emoji_Presentation} - \p{RI}] ⊂ \p{ea=W}

##########################
# POSIX Compatibility Properties (UTS#18)
# http://www.opengroup.org/onlinepubs/007904975/basedefs/xbd_chap07.html
##########################

# constants

Let $SP = [\u0020]	# [\N{space}]
Let $TAB = [\u0009] # [\N{CHARACTER TABULATION}]
Let $LF = [\u000A]	# \N{linefeed}
Let $VTAB = [\u000B]	# [\N{LINE TABULATION}]
Let $FF = [\u000C]	# [\N{formfeed}]
Let $CR = [\u000D]	# \N{carriage return}
Let $NEL = [\u0085]	# \N{next line}
#Let $ZWNJ = [\u200C]	# [\N{ZERO WIDTH NON-JOINER}]
#Let $ZWJ = [\u200D]	# [\N{ZERO WIDTH JOINER}]

Let $CircledAsciiLetters = [\u24B6-\u24E9]

# Unassigned, Control, Format, Private_Use, Surrogate, 
# Uppercase_Letter, Lowercase_Letter, Titlecase_Letter, Modifier_Letter, Other_Letter,
# Nonspacing_Mark, Enclosing_Mark, Spacing_Mark,
# Decimal_Number, Letter_Number, Other_Number, 
# Space_Separator, Line_Separator, Paragraph_Separator, 
# Dash_Punctuation, Open_Punctuation, Close_Punctuation, Connector_Punctuation, Other_Punctuation, Initial_Punctuation, Final_Punctuation
# Math_Symbol, Currency_Symbol, Modifier_Symbol, Other_Symbol

# UTS Rules

Let $alpha = [\p{Alphabetic} $CircledAsciiLetters]
Let $lower = \p{Lowercase} 
Let $upper = [\p{Uppercase}]
Let $punct = [$gcAllPunctuation $gcAllSymbols - $alpha]
Let $digit = \p{gc=Decimal_Number} 
Let $xdigit = [\p{gc=Decimal_Number} \p{Hex_Digit}] # in both!
Let $alnum = [$alpha $digit]
Let $space = \p{Whitespace} 
Let $blank = [\p{Whitespace} - [$LF $VTAB $FF $CR $NEL \p{gc=Line_Separator} \p{gc=Paragraph_Separator}]]
Let $cntrl = \p{gc=Control} 
Let $graph = [^$space \p{gc=Control} \p{gc=Surrogate} \p{gc=Unassigned}]
Let $print = [$graph $blank - $cntrl]
Let $word = [$alpha $gcAllMarks $digit \p{gc=Connector_Punctuation}] 

# ===========================

# POSIX locale definition file constraints

$upper ∥ [$cntrl $digit $punct $space]
$upper ⊇ [A-Z]

$lower ∥ [$cntrl $digit $punct $space]
$lower ⊇ [a-z]

$alpha ∥ [$cntrl $digit $punct $space]
$alpha ⊇ [$lower $upper]

$digit ⊇ [0-9]

$alnum = [$alpha $digit]

$space ∥ [$upper $lower $alpha $digit $graph $xdigit]
$space ⊇ [$SP $FF $LF $CR] # $TAB $VTAB $NEL]
$space ⊇ $blank

$cntrl ∥ [$upper $lower $alpha $digit $punct $graph $print $xdigit]

$punct ∥ [$upper $lower $alpha $digit $cntrl $xdigit $SP]

$graph ⊇ [$upper $lower $alpha $digit $xdigit $punct]
$graph ∥ [$SP $cntrl]

$print ⊇ [$upper $lower $alpha $digit $xdigit $punct $graph $SP]
$print ∥ $cntrl

$xdigit ⊇ [$digit [a-f A-F]]

$blank ⊇ [$SP $TAB]

# Extra POSIX 'POSIX locale' constraints

Let $C0Controls = [\u0000-\u001F]

$cntrl ⊇  $C0Controls

$punct  ⊇ [[\u0021-\u007E] - [0-9 A-Z a-z]]

[$alpha $lower $upper $punct $digit $xdigit $alnum $space $blank $cntrl $graph $print $word] = [^\p{gc=unassigned} \p{gc=surrogate}]

# Map tests

# Verify that the mappings in Case_Folding for the old characters
# are the same as the previous version's.
# TODO: Update the versions each time.
# TODO: Make the UnicodeMapParser understand versioned properties (and \P not just \p)
# so that we can intersect the left side with \P{U-1:gc=Cn}
# (assigned characters in the previous version) for automatic updates.
# BUG: It looks like \p{age=13.0} includes only the characters *added new* in 13.0,
# not also all of the earlier ones.
# We should be able to use:
# Map {\m{Case_Folding}&\P{U-1:gc=Cn}} = {\m{*Case_Folding}]}

# Commented out because excruciatingly slow, and tested systematically above with an In line.
# TODO(macchiati): Make this faster.
# Map {\m{Case_Folding}&[^\p{age=14.0}]} = {\m{*Case_Folding}&[^\p{age=14.0}]}

# The following are 'red flag' tests, just so that we review the changes and make sure they are ok.

# Ideographic invariants

Let $ideohack = [〆 〇 〡-〩]

[\p{ideographic}-\p{sc=tangut}-\p{sc=nushu}-\p{sc=Khitan_Small_Script}-\p{nfkcqc=n}-$ideohack] = \p{Unified_Ideograph}
# 10.0 added Nushu
# 13.0 added Khitan_Small_Script

# Following don't work yet. Tested independently in TestInvariants
# \p{Unified_Ideograph} ⊇ \P{kRSUnicode=∅}

# \p{Unified_Ideograph} = \P{kRSUnicode=∅}

# \P{kRSUnicode=∅} = \P{kTotalStrokes=∅}

# \P{kHanyuPinyin=∅} ⊇ \P{kMandarin=∅}

# InPC-InSC-gc invariants
# See https://www.unicode.org/L2/L2023/23200-category-invariants.pdf.
\p{InPC=/(Left|Right)/} ⊆ [\p{gc=Mc}\p{gc=Lo}\p{gc=Lm}]
[\P{InPC=NA}&\p{gc=Mc}] ⊆ \p{InPC=/(Left|Right)/}
[\P{InPC=NA}&\P{InPC=/(Left|Right)/}] ⊆ [\p{gc=Mn}\p{gc=Lo}]
\p{gc=Mn} ⊆ \P{InPC=/(Left|Right)/}
[\p{gc=Lo}&\P{InPC=NA}&\P{InPC=/(Left|Right)/}] ⊆ [\p{InSC=Consonant_Preceding_Repha}\p{InSC=Consonant_Prefixed}]
